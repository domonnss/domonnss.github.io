<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>l4rk&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="l4rk"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="l4rk"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="l4rk"><meta property="og:url" content="https://l4rk.cn/"><meta property="og:site_name" content="l4rk"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://l4rk.cn/img/og_image.png"><meta property="article:author" content="l4rk"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://github.com"},"headline":"l4rk's blog","image":["http://github.com/img/og_image.png"],"author":{"@type":"Person","name":"l4rk"},"publisher":{"@type":"Organization","name":"l4rk's blog","logo":{"@type":"ImageObject","url":"http://github.com/img/logo.svg"}},"description":""}</script><link rel="alternate" href="/atom.xml" title="l4rk&#039;s blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><!--!--><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="l4rk&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">文章归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/domonnss"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-27T12:25:09.880Z" title="2023/11/27 20:25:09">2023-11-27</time>发表</span><span class="level-item"><time dateTime="2023-11-28T12:56:56.473Z" title="2023/11/28 20:56:56">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/tech/">tech</a></span><span class="level-item">1 分钟读完 (大约113个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/0f5b30ebc6d1.html">dns</a></h1><div class="content"><p>DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址(IP address)转换的服务器。</p>
<p><strong>IP地址是唯一确定的.但访问网页的时候输入的往往是域名,例如: <a target="_blank" rel="noopener" href="https://www.baidu.com">https://www.baidu.com</a>. 想要访问这个网址,DNS服务器就会对网址进行解析,找到网址对应的IP地址,并将IP地址返回,从而实现访问.</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-27T12:24:35.637Z" title="2023/11/27 20:24:35">2023-11-27</time>发表</span><span class="level-item"><time dateTime="2023-11-28T12:57:12.858Z" title="2023/11/28 20:57:12">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/tech/">tech</a></span><span class="level-item">1 分钟读完 (大约155个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/6b01a7b16a40.html">oos</a></h1><div class="content"><p>首先OSS的英文全称是Object Storage Service, 直译过来就是”对象存储服务“。 严谨的解释是：OSS是一种使用HTTP API存储和检索非结构化数据和元素的数据对象的工具。 要点：</p>
<ol>
<li>HTTP API风格</li>
<li>存储数据</li>
<li>检索数据</li>
</ol>
<p>通俗易懂的说就是：OSS就是通过HTTP restful风格的API进行数据上传，存储和获取的云端数据库服务。你也可以简单的理解成网盘。</p>
<p>服务供应商： 阿里云，蓝队云，移动云，AWS存储</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-26T06:04:41.764Z" title="2023/11/26 14:04:41">2023-11-26</time>发表</span><span class="level-item"><time dateTime="2023-11-28T12:56:50.034Z" title="2023/11/28 20:56:50">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/tech/">tech</a></span><span class="level-item">几秒读完 (大约74个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/74ebd10381d1.html">api</a></h1><div class="content"><p>api能实现程序之间的数据交流,也能实现,客户端与服务器端口的数据交流.</p>
<p>服务器API接口,是指在自己的服务器上构建一个API，以便其他应用程序可以通过网络请求与之交互。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-26T06:02:28.240Z" title="2023/11/26 14:02:28">2023-11-26</time>发表</span><span class="level-item"><time dateTime="2023-11-28T12:56:54.284Z" title="2023/11/28 20:56:54">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/tech/">tech</a></span><span class="level-item">2 分钟读完 (大约286个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/8b337fe9c1ef.html">cdn</a></h1><div class="content"><p>全称为内容分发网络,Content Delivery Network，简称CDN.建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。<br>内容分发网络（CDN）是一个互连服务器网络，可加快数据密集型应用程序的网页加载速度。CDN 可以表示内容分发网络或内容分配网络。当用户访问某个网站时，来自该网站服务器的数据必须通过互联网传输到用户的计算机。如果用户距离该服务器较远，则加载大文件（例如视频或网站图像）将需要很长时间。相反，如果网站内容存储在距离用户较近的 CDN 服务器上，就可以更快到达他们的计算机。</p>
<p><strong>对于每一个资源请求,响应一个最近的边缘服务器.如果边缘服务器中没有需要的资源,再去源服务器请求.减小源服务器的压力.</strong><br><img src="http://172.16.36.4:9000/picture-bucket/20231128142107.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-25T12:50:28.523Z" title="2023/11/25 20:50:28">2023-11-25</time>发表</span><span class="level-item"><time dateTime="2023-11-28T12:57:52.957Z" title="2023/11/28 20:57:52">2023-11-28</time>更新</span><span class="level-item">1 分钟读完 (大约123个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/11/dcbe7675465f.html">hello-world&#039;</a></h1><div class="content"><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-08T11:44:44.360Z" title="2023/10/8 19:44:44">2023-10-08</time>发表</span><span class="level-item"><time dateTime="2023-11-28T13:30:21.816Z" title="2023/11/28 21:30:21">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/tech/">tech</a><span> / </span><a class="link-muted" href="/categories/tech/games/">games</a></span><span class="level-item">22 分钟读完 (大约3310个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/f85834e8ad59.html">101</a></h1><div class="content"><p>Lingqi Yan </p>
<h1 id="crucial"><a href="#crucial" class="headerlink" title="crucial"></a>crucial</h1><ul>
<li>对于复合变换,一定是先线性变换,再非线性变换</li>
<li></li>
</ul>
<h1 id="Lec1-overview-of-Computer-Graphic"><a href="#Lec1-overview-of-Computer-Graphic" class="headerlink" title="Lec1 overview of Computer Graphic"></a>Lec1 overview of Computer Graphic</h1><p>判断游戏画面水平如何<br>可以去看画面的明暗.亮的,一般都是采用了全局光照技术.从技术层面来看更加优秀</p>
<p>特效是最简单的图形学技术应用<br>特效是特殊的效果.在平常生活中见得很少,即使特效出错,观众不一定看得出来.而对日常东西的渲染更为困难</p>
<p>Visualization<br>Virtual Reality<br>Digital Illustration数字图像处理<br>Simulation<br>Graphic User Interface<br>Typography矢量字体?</p>
<ul>
<li><code>course topic</code><ul>
<li>Rasterazation</li>
<li>Curves and Meshes</li>
<li>Ray Tracing </li>
<li>Animation / Simulation</li>
</ul>
</li>
</ul>
<p>CG与CV<br>一切需要理解,猜测的都是计算机视觉的内容.<br>no clear boundaries</p>
<h1 id="Lec2-Review-of-Linear-Algebra"><a href="#Lec2-Review-of-Linear-Algebra" class="headerlink" title="Lec2 Review of Linear Algebra"></a>Lec2 Review of Linear Algebra</h1><p>A Swift and Brutal Introduction to Linear Algebra</p>
<h2 id="Vectors"><a href="#Vectors" class="headerlink" title="Vectors"></a>Vectors</h2><p>$\vec {a}$ 或者$\boldsymbol {a}$</p>
<h3 id="dot-product-点乘"><a href="#dot-product-点乘" class="headerlink" title="dot product 点乘"></a>dot product 点乘</h3><p>$\vec {a} \cdot \vec{b}=\lvert \vec{a} \rvert \lvert \vec{b} \rvert \cos\theta$<br>$\cos\theta=\frac{\vec{a} \cdot \vec{b}}{\lvert\vec{a}\rvert\lvert \vec{b} \rvert}0$<br>for unit Vectors<br>$\cos \theta=\hat{a} \cdot \hat{b}$<br>符合</p>
<ol>
<li>交换律</li>
<li>结合律</li>
<li>分配律 </li>
</ol>
<p>用矩阵表达的点乘计算更加简单直接<br>在二维<br>$\vec{a} \cdot \vec{b}=\begin{pmatrix}x_{a} \\ y_{a} \\ \end{pmatrix}\cdot \begin{pmatrix}x_{b} \\ y_{b}\end{pmatrix}=x_{a}x_{b}+y_{a} y_{b}$</p>
<p>同理对于三维</p>
<p>$\vec{a} \cdot \vec{b}=\begin{pmatrix}x_{a} \\ y_{a} \\z_{a} \end{pmatrix}\cdot \begin{pmatrix}x_{b} \\ y_{b} \\ z_{b}\end{pmatrix}=x_{a} x_{b}+y_{a} y_{b}+z_{a} z_{b}$</p>
<p><strong>主要是用来寻找投影</strong></p>
<p>对于$\vec{b}$在$\vec{a}$上的投影$\vec{b}\perp$<br>$\vec{b}\perp=\lvert\vec{b}\perp\rvert \cdot\hat{a}=\lvert\vec{b}\rvert\hat{a} \cos\theta$<br>若$\vec{a}$为$\hat{a}$,则<br>$\vec{b}\perp=\lvert\vec{b}\rvert \vec{a} \cos\theta =(\vec{b} \cdot \vec{a})\vec{a}$  ^fae5ki</p>
<p>用处:<br>观察点乘结果判断</p>
<ol>
<li>两个向量是否接近</li>
<li>两个向量的前后位置关系<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231011192317.png" alt=""></li>
</ol>
<h3 id="cross-product"><a href="#cross-product" class="headerlink" title="cross product"></a>cross product</h3><p>$\vec{a} \times \vec{b}=-\vec{b} \times \vec{a}$</p>
<p>$\lvert \vec{a} \times \vec{b} \rvert=\lvert \vec{a} \rvert  \lvert \vec{b} \rvert \sin\theta$</p>
<p>方向上采用右手定则</p>
<p>没有<strong>交换律</strong>但符合分配律和结合律</p>
<p>$\vec{a} \times \vec{a}=\vec{0}$</p>
<p>是向量,不是单纯的$0$</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231011194217.png" alt=""></p>
<p>$\vec{a}\times\vec{b}=A^{*}b=\left(\begin{array}{l l l}0&amp;{-z_{a}}&amp;{y_{a}}\\ {z_{a}}&amp;{0}&amp;{-x_{a}}\\ {-y_{a}}&amp;{x_{a}}&amp;0\end{array}\right)\left(\begin{array}{l}{x_{b}}\\ {y_{b}}\\ {z_{b}}\end{array}\right)$</p>
<p>$\vec{a}\times\vec{b}\;=\;\left(\begin{array}{l l}{y_{a}z_{b}-y_{b}z_{a}}\\ {z_{a}x_{b}-x_{a}z_{b}}\\ {x_{a}y_{b}-y_{a}x_{b}}\end{array}\right)$</p>
<p>作用:<br>通过<br>叉乘结果判断</p>
<ol>
<li>左和右<br> if($\vec{a} \times \vec{b}=\vec{z}$)<br> then,$\vec{b}$在$\vec{a}$左侧<br> if($\vec{a} \times \vec{b}=-\vec{z}$)<br> then,$\vec{b}$在$\vec{a}$右侧</li>
<li>内和外<br> 利用左右判断<br> if($\overrightarrow{AP} \times \overrightarrow{AB}=\overrightarrow{BP} \times \overrightarrow{BC}=\overrightarrow{CP} \times \overrightarrow{CA}$)<br> then,p在内侧<br> <img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231011195337.png" alt=""></li>
</ol>
<p>在3D情况下寻找投影<br>类似于二维的情况<br><img src="101#^fae5ki" alt=""></p>
<p>若<br>$\begin{array}{c}{||\overrightarrow{v}||=||\overrightarrow{w}||=||\overrightarrow{v}||=1}\\ {\overrightarrow{u}\cdot\overrightarrow{v}=\overrightarrow{u}\cdot\overrightarrow{w}=\overrightarrow{v}\cdot\overrightarrow{w}=0}\\ {\overrightarrow{w}=\overrightarrow{u}\times\overrightarrow{v}}&amp;{\scriptscriptstyle\mathrm{(右手系)}}\end{array}$<br>则<br>$\vec{p}\perp=(\vec{p}\cdot\vec{u})\vec{u}+(\vec{p}\cdot\vec{v})\vec{v}+(\vec{p}\cdot\vec{w})\vec{w}$</p>
<h3 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h3><p>矩阵的乘法<br>$\begin{pmatrix}1&amp;3 \\ 2&amp;4 \\3&amp;3 \\  \end{pmatrix} \begin{pmatrix}2 &amp;5\\ 1&amp;6\end{pmatrix}=\begin{pmatrix}x&amp;x \\ x&amp;x \\ x&amp;x\end{pmatrix}$<br>不符合交换律但符合结合律和分配律<br>将向量vector视作列向量m*1的矩阵</p>
<p>矩阵的转置<br>$(AB)^T=B^{T}A^T$</p>
<p>单位矩阵$I_{3*3}=\begin{pmatrix}1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\ \end{pmatrix}$<br>对于逆运算$A^{-1}$<br>$AA^{-1}=A^{-1}A=I$<br>$(AB)^{-1}=B^{-1}A^{-1}$</p>
<p><strong>将点乘与叉乘转换为矩阵乘法</strong><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231015201401.png" alt=""></p>
<h1 id="Lec3-Transformation-A"><a href="#Lec3-Transformation-A" class="headerlink" title="Lec3 Transformation A"></a>Lec3 Transformation A</h1><ul>
<li>transformation<ul>
<li>modeling<ol>
<li>rotation</li>
<li>scaling</li>
</ol>
</li>
<li>viewing<ol>
<li>projection</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="homogeneous-coordinate-齐次坐标"><a href="#homogeneous-coordinate-齐次坐标" class="headerlink" title="homogeneous coordinate 齐次坐标"></a>homogeneous coordinate 齐次坐标</h2><p>为解决Translation问题,齐次坐标堂堂登场</p>
<ul>
<li>$2D point=\begin{pmatrix}x \\ y \\ 1\end{pmatrix}$</li>
<li>$2D vector=\begin{pmatrix}x \\ y \\ 0\end{pmatrix}$</li>
</ul>
<ul>
<li>为什么 point用1补位 vector用0补位?<br>对于向量来说,人类希望它由平移不变的性质.所以用0来保护它<ul>
<li>1的情况<script type="math/tex; mode=display">\left(\begin{array}{c c c}{x^{\prime}}\\ {y^{\prime}}\\ {w^{\prime}}\end{array}\right)\ =\ \left(\begin{array}{c c c}1&{0}&{t_{x}}\\ 0&1&{t_{y}}\\ 0&0&1\end{array}\right)\cdot\left(\begin{array}{c}\\ \\ 1\end{array}\right)=\ \left(\begin{array}{c}{x+t_{x}}\\ {y+t_{y}}\\ 1\end{array}\right)\</script></li>
<li>0的情况<script type="math/tex; mode=display">\left(\begin{array}{c c c}{x^{\prime}}\\ {y^{\prime}}\\ {w^{\prime}}\end{array}\right)\ =\ \left(\begin{array}{c c c}1&0&{t_{x}}\\ 0&1&{t_{y}}\\ 0&0&1\end{array}\right)\cdot\left(\begin{array}{c}\\ \\ 0\end{array}\right)=\ \left(\begin{array}{c}{x+t_{x}}\\ {y+t_{y}}\\ 0\end{array}\right)\</script>确保了即使是利用矩阵乘法计算向量平移不变</li>
</ul>
</li>
</ul>
<p>或者换一个角度看</p>
<ul>
<li>$vector+vector=vector$</li>
<li>$point-point=vector$</li>
<li>$point+vector=point$ 某个点沿着向量平移</li>
<li>$point+point=midpoint$<br>对于点$\begin{pmatrix}x \\ y \\ w \end{pmatrix}=\begin{pmatrix}x/w \\ y/w \\ 1\end{pmatrix}$</li>
<li>题外话:<br>trade off是一个在工程学科中必然存在的策略.齐次坐标虽然需要更多的性能<br>但能够将基础的变换统一起来</li>
</ul>
<p>增加的储存数据只有最后一列的$\begin{pmatrix}0 \\ 0 \\ 1\end{pmatrix}$与最后一行的$\begin{pmatrix}0,0,1\end{pmatrix}$,而且在大部分情况下,$\begin{pmatrix}0,0,1\end{pmatrix}$只要储存一个1就够了.性能开销不大的情况下实现了相当好的效果</p>
<h2 id="modeling"><a href="#modeling" class="headerlink" title="modeling"></a>modeling</h2><p><strong>先线性变换再平移</strong></p>
<h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>都可以用一个统一的矩阵来表示<br>$x \prime=ax+by$<br>$y \prime=cx+dy$</p>
<script type="math/tex; mode=display">\left[\begin{array}{l}{x^{\prime}}\\ {y^{\prime}}\end{array} \right] =\left[ \begin{array}{l l}{a}&{b}\\ &\end{array}\right] \left [\begin{array}{l}\\ \end{array} \right]</script><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231015214719.png" alt=""><br>缩放矩阵,缩放系数为$S_{x}=0.5,S_{y}=1.0$<br>$\left[\begin{array}{l}{x^{\prime}}\\ {y^{\prime}}\end{array}\right]=\left[\begin{array}{l l}{s_x}&amp;0\\ 0&amp;{s_y}\end{array}\right]\left[\begin{array}{l}\\ \end{array}\right]$</p>
<h4 id="reflection"><a href="#reflection" class="headerlink" title="reflection"></a>reflection</h4><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231015214811.png" alt="">$\left[\begin{array}{l}{x^{\prime}}\\ {y^{\prime}}\end{array}\right]=\left[\begin{array}{l l}1&amp;0\\ 0&amp;1\end{array}\right]\left[\begin{array}{l}{x}\\ {y}\end{array}\right]$</p>
<h4 id="sheer-拉伸"><a href="#sheer-拉伸" class="headerlink" title="sheer 拉伸"></a>sheer 拉伸</h4><p><img src="http://172.16.36.4:9000/picture-bucket/2023-11-22-19-47-55.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231015214940.png" alt=""></p>
<p>$\left[\begin{array}{l}{x^{\prime}}\\ {y^{\prime}}\end{array}\right]=\left[\begin{array}{l l}1&amp;{a}\\ 0&amp;{1}\end{array}\right]\left[\begin{array}{l}{x}\\ {y}\end{array}\right]$</p>
<h4 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h4><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231015215632.png" alt=""><br>写出正确的旋转矩阵,只需要找到前后变化的点的相对位置关系<br>$\left[\begin{array}{l}{x^{ \prime}}\\ {y^{\prime}}\end{array}\right]=R_{\theta}\left[\begin{array}{l}{x}\\ {y}\end{array}\right]$<br>$\left[\begin{array}{l}{x^{\prime}}\\ {y^{\prime}}\end{array}\right]=\left[\begin{array}{l l}{?}&amp;{?}\\ {?}&amp;{?}\end{array}\right]\left[\begin{array}{l}{x}\\ {y}\end{array}\right]$<br>推导$R_{\theta}$的值,可以由特殊到一般,<br>$\left[\begin{array}{l}{x^{\prime}}\\ {y^{\prime}}\end{array}\right]=(\cos\theta,\sin\theta)$带入推导随便算<br>对于旋转来说<br>$R_{-\theta}=\left[\begin{array}{c c}\cos\theta&amp;\sin\theta \\ -\sin\theta&amp;\cos\theta\end{array}\right]$<br>存在下列关系:<br>$R_{-\theta}=R_{\theta}^{T}$<br>可以用转秩简单求得$R_{-\theta}$</p>
<h4 id="线性变换的齐次坐标表示"><a href="#线性变换的齐次坐标表示" class="headerlink" title="线性变换的齐次坐标表示"></a>线性变换的齐次坐标表示</h4><p>  <img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231015231731.png" alt=""></p>
<h3 id="非线性变换"><a href="#非线性变换" class="headerlink" title="非线性变换"></a>非线性变换</h3><h4 id="Translation-平移变换"><a href="#Translation-平移变换" class="headerlink" title="Translation 平移变换"></a>Translation 平移变换</h4><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231015222820.png" alt=""><br>平移不是一个线性变换<br>为了避免这样的情况<br>引入了齐次坐标来解决</p>
<p>在齐次坐标下平移的表示<br>$\left(\begin{array}{c c c}{x^{\prime}}\\ {y^{\prime}}\\ {w^{\prime}}\end{array}\right)\ =\ \left(\begin{array}{c c c}1&amp;0&amp;{t_{x}}\\ 0&amp;1&amp;{t_{y}}\\ 0&amp;0&amp;1\end{array}\right)\cdot\left(\begin{array}{c}{x}\\ {y}\\ 1\end{array}\right)$</p>
<h4 id="affine-transform仿射变换"><a href="#affine-transform仿射变换" class="headerlink" title="affine transform仿射变换"></a>affine transform仿射变换</h4><p>仿射变换:线性变换再接上平移<br>对于这样的操作来说,无法简单的写成与上方统一的矩阵相乘的形式<br>只能写成<br>$\left[\begin{array}{l}{x^{\prime}}\\ {y^{\prime}}\end{array}\right]=\left[\begin{array}{l l}{a}&amp;{b}\\ {c}&amp;{d}\end{array}\right]\left[\begin{array}{l}{x}\\ {y}\end{array}\right]+\left[\begin{array}{l}{t_{x}}\\ {t_{y}}\end{array}\right]$</p>
<p>但通过齐次坐标<br>可以写成</p>
<script type="math/tex; mode=display">\left(\begin{array}{c c c}{x^{\prime}}\\ {y^{\prime}}\\ 1\end{array}\right)\ =\ \left(\begin{array}{c c c}&&{t_{x}}\\ &&{t_{y}}\\ 0&0&1\end{array}\right)\cdot\left(\begin{array}{c}\\ \\ 1\end{array}\right)=\ \left(\begin{array}{c}{ax+by+t_{x}}\\ {cx+dy+t_{y}}\\ 1\end{array}\right)\</script><h3 id="composing-transform-组合变换"><a href="#composing-transform-组合变换" class="headerlink" title="composing transform 组合变换"></a>composing transform 组合变换</h3><p>矩阵乘法的顺序会影响结果<br>所以变换顺序的不同也会影响结果<br>$R_{45}\cdot T_{(1,0)} \neq T_{(1,0)} \cdot R_{45}$</p>
<p>默认情况下先做旋转再做平移<br>对于下式来说<br>$T_{(1,0)}\cdot  R_{45}\ \left [\begin{array}{c}x\\ y\\1\end{array}\right]$<br>先做旋转再做平移</p>
<p>对于一系列操作来说<br>$A_{n}(A_{n-1}(A_{n-2}…(A_{1})))$可以先合成之前的矩阵,最终变成$A_{(3<em>3)} \cdot \begin{pmatrix}x \\ y \\ 1\end{pmatrix}$<br>$A_{(3</em>3})$能够表达无数多的复杂变换</p>
<h4 id="非原点旋转"><a href="#非原点旋转" class="headerlink" title="非原点旋转"></a>非原点旋转</h4><p>$T_{c} \cdot R_{\alpha} \cdot T_{-c}$<br>顺序是从左到右<br>先平移到原点,再旋转,最后再平移回去</p>
<h3 id="inverse-transform-逆变换"><a href="#inverse-transform-逆变换" class="headerlink" title="inverse transform 逆变换"></a>inverse transform 逆变换</h3><p>使用逆矩阵就可以完成逆变换<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231015232424.png" alt=""></p>
<h1 id="Lec4-Transformation-B"><a href="#Lec4-Transformation-B" class="headerlink" title="Lec4 Transformation B"></a>Lec4 Transformation B</h1><p>How to get a photo?</p>
<ol>
<li>摆pose modeling transformation</li>
<li>选相机位置 viewing transformation</li>
<li>按快门 projection transformation<br>MVP!<br>modeling viewing projection</li>
</ol>
<h2 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h2><h4 id="3D-Transformation"><a href="#3D-Transformation" class="headerlink" title="3D  Transformation"></a>3D  Transformation</h4><ul>
<li>$3D point=\begin{pmatrix}x \\ y  \\ z\\ 1\end{pmatrix}$</li>
<li>$3D vector=\begin{pmatrix}x \\ y \\z \\  0\end{pmatrix}$<br>$\begin{pmatrix}x \\ y  \\ z\\ w\end{pmatrix}=\begin{pmatrix}x /w\\ y/w  \\ z/w\\ 1\end{pmatrix}$</li>
</ul>
<h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p>平移仍然在最后一列</p>
<script type="math/tex; mode=display">\left(\begin{array}{c c c}{x^{\prime}}\\ {y^{\prime}}\\ \\1\end{array}\right)\ =\ \left(\begin{array}{c c c c}{a}&{b}&c&{t_{x}}\\ {d}&{e}&f&{t_{y}}\\g&h&i&t_{z}\\ 0&0&0&1\end{array}\right)\cdot\left(\begin{array}{c}{x}\\ {y}\\z\\ 1\end{array}\right)=\ \left(\begin{array}{c}{ax+by+cz+t_{x}}\\ {dx+ey+fz+t_{y}}\\gx+hy+di+t_{z}\\ 1\end{array}\right)\</script><h4 id="scale-1"><a href="#scale-1" class="headerlink" title="scale"></a>scale</h4><script type="math/tex; mode=display">S_(s_{x},s_{y},s_{z})=\begin{pmatrix}s_{x}&0&0&0 \\ 0&s_{y}&0&0 \\ 0&0&s_{z}&0 \\ 0&0&0&1 \\ \end{pmatrix}</script><h4 id="reflection-1"><a href="#reflection-1" class="headerlink" title="reflection"></a>reflection</h4><h4 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h4><script type="math/tex; mode=display">T_(t_{x},t_{y}t_{z})=\begin{pmatrix}
1&0&0&t_{x} \\ 0&1&0&t_{y} \\ 0&0&1&y_{z} \\ 0&0&0&1 \\ 
\end{pmatrix}</script><h4 id="sheer"><a href="#sheer" class="headerlink" title="sheer"></a>sheer</h4><h4 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h4><ul>
<li>沿着x轴旋转<script type="math/tex; mode=display">\mathbf{R}_{x}(\alpha)={\left(\begin{array}{l l l l}{1}&{0}&{0}&{0}\\ {0}&{\cos\alpha}&{-\sin\alpha}&{0}\\ {0}&{\sin\alpha}&{\cos\alpha}&{0}\\ {0}&{0}&{0}&{1}\end{array}\right)}</script></li>
<li>沿着y轴旋转<br>是最特殊的一个,右上角是$\sin\alpha$<br>下见推算过程<script type="math/tex; mode=display">\mathbf{R}_{y}(\alpha)={\left(\begin{array}{l l l l}{\cos\alpha}&{0}&{\sin\alpha}&{0}\\ {0}&{1}&{0}&{0}\\ {-\sin\alpha}&{0}&{\cos\alpha}&{0}\\ {0}&{0}&{0}&{1}\end{array}\right)}</script></li>
<li>沿着z轴旋转<script type="math/tex; mode=display">\mathbf{R}_{y}(\alpha)={\left(\begin{array}{l l l l}{\cos\alpha}&{-\sin\alpha}&{0}&{0}\\ {\sin\alpha}&{\cos\alpha}&{0}&{0}\\ {0}&{0}&{1}&{0}\\ {0}&{0}&{0}&{1}\end{array}\right)}</script></li>
</ul>
<p>对于任意的3D旋转来说,可以分解为一个在3D直角坐标系中的<br>$R_{xyz}(\alpha\beta\gamma)=R_{x}(\alpha)R_{y}(\beta)R_{z}(\gamma)$<br>三个绕各个轴旋转的矩阵相乘<br>$\alpha,\beta,\gamma$叫做欧拉角(Euler Angles)<br>战地中的开飞机也是这样</p>
<ul>
<li><p>Rodrigues’ Rotation Formula<br>rotation by angle $\alpha$ around axis $n$</p>
<script type="math/tex; mode=display">\mathrm{R}({\bf n},\alpha)~=~\mathrm{cos}(\alpha){\bf I}~+~(1-\cos(\alpha))~{\bf n}^{T}~+~\sin(\alpha)\left(\begin{array}{l l l}0&{-n_{z}}&{n_{y}}\\ {n_{z}}&0&{-n_{x}}\\ {-n_{y}}&{n_{x}}&0\\ \end{array}\right)</script><p>这部分$\sin\alpha\left(\begin{array}{l l l}0&amp;{-n_{z}}&amp;{n_{y}}\\ {n_{z}}&amp;0&amp;{-n_{x}}\\ {-n_{y}}&amp;{n_{x}}&amp;0\\ \end{array}\right)$是叉乘的矩阵表达形式</p>
</li>
</ul>
<h2 id="viewing-camera-视图变换"><a href="#viewing-camera-视图变换" class="headerlink" title="viewing/camera 视图变换"></a>viewing/camera 视图变换</h2><p>基础:<br>相机的位置      $\vec{e}$          人的位置<br>相机看向的方向  $\hat{g}$          眼睛朝向<br>相机顶部向量    $\hat{t}$          脑袋歪斜方向<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231016210059.png" alt=""></p>
<p>在物理学的角度,可以将物体的移动看成,相机位置不动,其他物体相对运动.<br>于是把相机固定在标准位置,<br>即<br>相机位于原点,永远看向-z轴,顶部指向y轴正方向<br>即<br>$\vec{e}=(0,0,0)$<br>$\hat{g}=(0,0,-1)$<br>$\hat{t}=(0,1,0)$<br>让操作计简化</p>
<p>标准化流程<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231016210815.png" alt=""></p>
<ol>
<li>$T_{view}=\left[\begin{array}{c c c c}1&amp;0&amp;0&amp;-x_{e}\\ 0&amp;1&amp;0&amp;-y_{e}\\0&amp;0&amp;1&amp;-z_{e}\\0&amp;0&amp;0&amp;1\end{array}\right]$</li>
<li>将后面几步旋转矩阵计算为同一个矩阵可得逆矩阵$R_{view}^{-1}$.由于矩阵$R_{view}$计算困难,故使用逆矩阵<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231016213934.png" alt=""><br>第一行为(g x t) To X 结果<br>第二行为t To Y的结果<br>第三行为g To -Z的结果</li>
</ol>
<h2 id="projection-投影变换"><a href="#projection-投影变换" class="headerlink" title="projection  投影变换"></a>projection  投影变换</h2><ul>
<li>orthographic projection 正交投影</li>
<li>perspective projection 透视投影<h3 id="orthographic-projection-正交投影"><a href="#orthographic-projection-正交投影" class="headerlink" title="orthographic projection 正交投影"></a>orthographic projection 正交投影</h3></li>
</ul>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231016220340.png" alt=""><br>把z轴直接去掉,再进行平移与缩放到$[-1,1]^{2}$范围内,就可以得到正交投影的结果</p>
<p>工程上的做法<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231016220921.png" alt=""><br>注意,</p>
<ul>
<li>左右的范围为[l,r],left\&lt;right</li>
<li>上下的范围为[b,t],bottom\&lt;top</li>
<li><strong>前后的范围为[f,n],far\&lt;near</strong>.因为我们看向的方向是-z,例如f=-9,n=1.       </li>
</ul>
<p>变换矩阵为</p>
<script type="math/tex; mode=display">M_{ortho}=\left[\begin{array}{c c c c}\frac{2}{r-l}&0&0&0\\0&\frac{2}{t-b}&0&0\\0&0&\frac{2}{n-f}&0\\0&0&0&1
\end{array}\right]
\left[\begin{array}{c c c c}1&0&0&-\frac{r+l}{2}\\0&1&0&-\frac{t+b}{2}\\0&0&1&-\frac{f+n}{2}\\0&0&0&1
\end{array}\right]</script><p>后一个为了平移立方体中点至原点<br>前一个为了缩放立方体到$[-1,1]^{2}$范围</p>
<p>但现在并没有完全完成变换,因为缩放的过程中存在拉伸,还需要后续的视口变换来矫正<br>也存在精度上的问题.把大的立方体缩放到小立方体,会导致信息损失</p>
<h3 id="perspective-transformation-透视投影"><a href="#perspective-transformation-透视投影" class="headerlink" title="perspective transformation 透视投影"></a>perspective transformation 透视投影</h3><ul>
<li>视锥如何定义?<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018152547.png" alt=""><br>定义一个fov-Y(垂直可视角度),再定义一个aspect ratio(宽高比),就可以确定视锥的形状<br>其他的数据都可以简单计算出来$n,t,l$等等</li>
</ul>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231016223900.png" alt=""><br>将从视锥通过投影面截出来的截锥体挤压成cuboid,再进行正交投影,就可以得到透视投影<br>只要求得$M_{persp\rightarrow ortho}$就行力</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231016224617.png" alt=""><br>显而易见<br>$y^\prime=\frac{n}{z}y$<br>$x^\prime=\frac{n}{z}x$<br>但$z^{\prime}$仍然不清楚</p>
<p>得到</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
x^\prime \\ y^\prime \\ z^\prime \\ 1
\end{pmatrix}=
\begin{pmatrix}
\frac{n}{z}x\\\frac{n }{z}y \\ unknown\\1
\end{pmatrix}=
\begin{pmatrix}
nx \\ nz \\ still\ unknown \\ z
\end{pmatrix}</script><script type="math/tex; mode=display">M_{persp\rightarrow ortho}\begin{pmatrix}
x\\y \\ z \\ 1 \\ 
\end{pmatrix}=\begin{pmatrix}
x^\prime \\ y^\prime \\ z^\prime \\ 1
\end{pmatrix}=
\begin{pmatrix}
nx \\ nz \\ still\ unknown \\ z
\end{pmatrix}</script><p>可推算得</p>
<script type="math/tex; mode=display">M_{persp\rightarrow ortho}=\begin{pmatrix}
n&0&0&0 \\ 0&n&0&0 \\ ?&?&?&? \\ 0&0&1&0
\end{pmatrix}</script><p>而根据定义,近平面,z不变可知<br>将$z=n$带入</p>
<script type="math/tex; mode=display">\begin{pmatrix}
x^\prime \\ y^\prime \\ z^\prime \\ 1
\end{pmatrix}=
\begin{pmatrix}
\frac{n}{z}x\\\frac{n }{z}y \\ n\\1
\end{pmatrix}=
\begin{pmatrix}
nx \\ nz \\ n^{2} \\ n
\end{pmatrix}</script><script type="math/tex; mode=display">M_{persp\rightarrow ortho}\begin{pmatrix}
x\\y \\ n \\ 1 \\ 
\end{pmatrix}=\begin{pmatrix}
x^\prime \\ y^\prime \\ z^\prime \\ 1
\end{pmatrix}=
\begin{pmatrix}
nx \\ nz \\ n^{2} \\ n
\end{pmatrix}</script><p>得</p>
<script type="math/tex; mode=display">M_{persp\rightarrow ortho}=\begin{pmatrix}
n&0&0&0 \\ 0&n&0&0 \\ ?&?&?&? \\ 0&0&1&0
\end{pmatrix}=\begin{pmatrix}
n&0&0&0 \\ 0&n&0&0 \\ 0&0&A&B \\ 0&0&1&0
\end{pmatrix}</script><script type="math/tex; mode=display">\begin{pmatrix}
0&0&A&B
\end{pmatrix}
\begin{pmatrix}
x \\ y \\ n \\ 1
\end{pmatrix}=n^{2}</script><p>再由远平面点经过变换f不变,同理可得</p>
<script type="math/tex; mode=display">\begin{pmatrix}
0&0&A&B
\end{pmatrix}
\begin{pmatrix}
x \\ y \\ f \\ 1
\end{pmatrix}=f^{2}</script><p>由上两式可得</p>
<script type="math/tex; mode=display">\begin{align}A=n+f  \\ B=-nf\end{align}</script><script type="math/tex; mode=display">M_{persp\rightarrow ortho}=\begin{pmatrix}
n&0&0&0 \\ 0&n&0&0 \\ 0&0&n+f&-nf \\ 0&0&1&0
\end{pmatrix}</script><p>最后得到透视矩阵<br>$M_{persp}=M_{ortho}M_{persp\rightarrow ortho}$</p>
<p>思考题:<br>对于$\frac{n+f}{2}$,经过变形之后,会更加靠近$n$还是$f$?</p>
<script type="math/tex; mode=display">\begin{align}
M_{persp\rightarrow ortho}\begin{pmatrix}
x \\ y \\ \frac{n+f}{2} \\ 1 \\ 
\end{pmatrix}=\begin{pmatrix}
n&0&0&0 \\ 0&n&0&0 \\ 0&0&n+f&-nf \\ 0&0&1&0
\end{pmatrix}
\begin{pmatrix}
x \\ y \\ \frac{n+f}{2} \\ 1 \\ 
\end{pmatrix}=\begin{pmatrix}
nx \\ ny \\ \frac{n^{2}+f^{2}}{2} \\ \frac{n+f}{2} 
\end{pmatrix}=\begin{pmatrix}
\frac{2n}{n+f}x \\ \frac{2n}{n+f}y \\ \frac{n^{2}+f^{2}}{n+f} \\ 1 
\end{pmatrix}
\end{align}</script><p>比较$\frac{n^{2}+f^{2}}{n+f}$与$\frac{n+f}{2}$得<br>$\frac{n^{2}+f^{2}}{n+f}\geq\frac{n+f}{2}$<br>更靠近n面</p>
<h1 id="Lec5-Rasterazation-Triangle"><a href="#Lec5-Rasterazation-Triangle" class="headerlink" title="Lec5 Rasterazation Triangle"></a>Lec5 Rasterazation Triangle</h1><ul>
<li>屏幕是一个数组,数组的单个元素是颜色信息</li>
<li>Raster\==screen in German</li>
<li>Pixel\==short for “picture for element”</li>
</ul>
<h2 id="canonical-规范的-cube-to-screen"><a href="#canonical-规范的-cube-to-screen" class="headerlink" title="canonical(规范的) cube to screen"></a>canonical(规范的) cube to screen</h2><ul>
<li>rules<ol>
<li>用(x,y)的形式表示</li>
<li>x,y为整数</li>
<li>像素表示范围为(0,0)到(width-1,height-1)</li>
<li>中心点在(x+0.5,y+0.5)</li>
<li>因为单个像素占有1*1空间,所以像素实际占据的屏幕空间为(0,0)~(width,height)</li>
</ol>
</li>
</ul>
<h2 id="view-port-视口变换"><a href="#view-port-视口变换" class="headerlink" title="view port 视口变换"></a>view port 视口变换</h2><p>将之前Transformation得到的$[-1,1]\times[-1,1]$的正方形变换到$[0,width]\times[0,height]$上,$z$先不管<br>viewport transform matrix</p>
<script type="math/tex; mode=display">M_{viewport}=
\begin{pmatrix}
\frac{width}{2}&0&0&\frac{width}{2} \\ 0&\frac{height}{2}&0&\frac{height }{2} \\ 0&0&1&0 \\ 0&0&0&1
\end{pmatrix}</script><p>左上$3\times3$负责缩放<br>第四列负责平移<br>和$z$有关的都不变</p>
<h2 id="显示原理"><a href="#显示原理" class="headerlink" title="显示原理"></a>显示原理</h2><p>显示的图像,存在于显卡的memory中.<br>告诉显示器读取哪块内存就能展示</p>
<h3 id="LCD"><a href="#LCD" class="headerlink" title="LCD"></a>LCD</h3><p>liquid crystal display<br>用液晶光栅对光偏振进行改变<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018163000.png" alt=""></p>
<h3 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h3><p>light emitting diode 发光二极管</p>
<h3 id="electronic-ink"><a href="#electronic-ink" class="headerlink" title="electronic ink"></a>electronic ink</h3><h2 id="triangle-Mesh"><a href="#triangle-Mesh" class="headerlink" title="triangle Mesh"></a>triangle Mesh</h2><p>why triangle?</p>
<ul>
<li>最基础的多边形</li>
<li>能够用三角形表示其他的多边形</li>
<li>三角形的三个点确保了他们在同一个平面中</li>
<li>内部外部很容易区分,可以用向量的叉积进行判断</li>
<li>定义了三个点$v_{1},v_{2},v_{3}$ value属性的值,就可以判断三角形内部某个点.value</li>
</ul>
<h2 id="光栅化方法"><a href="#光栅化方法" class="headerlink" title="光栅化方法"></a>光栅化方法</h2><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><p>对风景采样=拍照<br>对时间采样=video</p>
<p>将函数离散化的方法<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018164423.png" alt=""><br>采样算法示例<br>判断像素中心点是否在三角形中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x)</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y)</span><br><span class="line">  image[x][y] = inside(tri,</span><br><span class="line">  x + <span class="number">0.5</span>,</span><br><span class="line">  y + <span class="number">0.5</span>);</span><br><span class="line">  <span class="comment"># inside 函数的具体实现,依靠叉积判断点是否在三角形中</span></span><br><span class="line">  <span class="comment"># 对于中心点在边上的情况,可以自行决断</span></span><br></pre></td></tr></table></figure></p>
<h4 id="加速方法"><a href="#加速方法" class="headerlink" title="加速方法"></a>加速方法</h4><h5 id="bounding-box"><a href="#bounding-box" class="headerlink" title="bounding box"></a>bounding box</h5><p>用bounding box包围核来减少判断<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018165428.png" alt=""></p>
<h3 id="锯齿问题"><a href="#锯齿问题" class="headerlink" title="锯齿问题"></a>锯齿问题</h3><p>信号走样<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018170237.png" alt=""></p>
<h1 id="Lec6-Rasterazation-anti-aliasing-and-z-buffer"><a href="#Lec6-Rasterazation-anti-aliasing-and-z-buffer" class="headerlink" title="Lec6 Rasterazation anti-aliasing and z-buffer"></a>Lec6 Rasterazation anti-aliasing and z-buffer</h1><p>Sampling Artifacts (Errors / Mistakes / Inaccuracies) in Computer Graphics</p>
<p>artifacts</p>
<ul>
<li>Jaggies (Staircase Pattern) 锯齿</li>
<li>Moiré Patterns in Imaging 摩尔纹</li>
<li>Wagon Wheel Illusion (False Motion)</li>
</ul>
<p>原因:<br>Signals are changing too fast (high frequency),but sampled too slowly</p>
<h2 id="滤波采样"><a href="#滤波采样" class="headerlink" title="滤波采样"></a>滤波采样</h2><p>对原有的信号模糊(滤波)再采样<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018193313.png" alt=""></p>
<p>为什么不能先采样再模糊?<br>按照下面的理论来看,先采样会有频域的重叠,即使进行模糊之后,频域还是会重叠,导致信号出现较大的差错</p>
<h2 id="Fourier-series"><a href="#Fourier-series" class="headerlink" title="Fourier series"></a>Fourier series</h2><p>傅里叶级数是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86" title="采样定理">采样定理</a>原始证明的核心<br>任何周期函数都可以用正弦函数和余弦函数构成的无穷级数来表示<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018201411.png" alt=""></p>
<h2 id="Fourier-Transform"><a href="#Fourier-Transform" class="headerlink" title="Fourier Transform"></a>Fourier Transform</h2><p>傅里叶变换的正变换与负变换<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018194811.png" alt=""></p>
<p>通过频率分析,发现,对于变化太快的函数来说,采样不能够很好地体现函数本身的性质<br>低级傅里叶级数采样 失真较小<br>高级傅里叶级数采样 失真较大<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018201844.png" alt=""></p>
<p>甚至会有对于完全不同的函数进行采样,结果相同<br>仅仅通过采样,无法区分两种函数区别<br>所以才会有aliasing<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018202031.png" alt=""></p>
<h2 id="sample出现aliasing的原因分析"><a href="#sample出现aliasing的原因分析" class="headerlink" title="sample出现aliasing的原因分析"></a>sample出现aliasing的原因分析</h2><h3 id="频域与时域"><a href="#频域与时域" class="headerlink" title="频域与时域"></a>频域与时域</h3><p>Filtering = Getting rid of certain frequency contents<br>从时域到频域<br>越靠外频率越高</p>
<p>怎么样的图像是高频?<br>画面变化大的地方,边界,经过傅里叶变换之后生成的就是高频信号.<br>同理,图像变化小的地方,经过傅里叶变换之后生成的就是低频信号.</p>
<p>亮度代表在某个频率下,信号的强度<br>横竖的两条亮线先不管<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018202550.png" alt=""></p>
<p>高通滤波的效果<br>仅让高频通过,再经过逆傅里叶变换,生成图像<br>发现生成的图像是有意义的,大体描述了图像内容的边界</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018202941.png" alt=""><br>低通滤波的效果<br>能看到大致的图像,但看不见细节与边界<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018203316.png" alt=""></p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018203434.png" alt=""></p>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>filter=average=convolution<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018204758.png" alt=""></p>
<p>在时域上的卷积等于频域上的乘积<br>同时验证了,卷积=滤波,最左边的频域图像进行类似低通滤波效果的操作之后,变成了最右边的频域<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018205057.png" alt=""></p>
<p>时域上的乘积等于频域上的卷积</p>
<p>bigger box=lower frequency<br>用越大的box进行卷积,得到的图像越模糊,通过的频率越低</p>
<h3 id="从频域看采样的本质"><a href="#从频域看采样的本质" class="headerlink" title="从频域看采样的本质"></a>从频域看采样的本质</h3><p>Sampling = Repeating Frequency Contents<br>左边为函数的频域<br>右边为函数的时域<br>$f(c)$为频域冲击函数<br>$f(e)$为$f(c)$经过傅里叶变换之后生成的时域冲击函数<br>$f(a)\times f(c)=f(e)$<br>$f(b)\otimes f(d)=f(f)$<br>频域上的乘积等于时域上的卷积</p>
<p>从$f(f)$可知,<strong>采样在一直重复某个信号的频谱</strong><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018210154.png" alt=""></p>
<p>如果<strong>时域采样越稀疏,频域上,频谱就越密集</strong>,重叠在一起就会发生走样</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018211130.png" alt=""></p>
<h2 id="how-can-we-reduce-aliasing-error"><a href="#how-can-we-reduce-aliasing-error" class="headerlink" title="how can we reduce aliasing error"></a>how can we reduce aliasing error</h2><ol>
<li>提升采样率<br>拥有更高分辨率的显示器</li>
<li>antialiasing<br>先做模糊再做采样<br>即低通滤波,把高频去除再采样<br>这样即使稀疏采样也能够得到足够好的采样结果<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018212926.png" alt=""></li>
</ol>
<p>在工程上,把图像模糊,即用低通滤波器,对图像进行卷积<br>filter之后像素内部的值就是卷积之后的结果<br>但计算原像素内部黑色占据的百分比不是一件简单的事情,所以我们有一项新技术:MSAA 超采样<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018213310.png" alt=""></p>
<h3 id="超采样"><a href="#超采样" class="headerlink" title="超采样"></a>超采样</h3><p>运用于模糊操作这个过程<br>既然单独计算原像素内部黑色占据的百分比不是一件简单的事情,那我们就在单个像素中进行超采样,将一个完整的像素视为多个小像素的组合.<br>再次采样后的结果近似于直接计算黑色占比<br>从而实现更好的抗锯齿效果<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018213950.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231018213932.png" alt=""></p>
<ul>
<li>the cost of MSAA<br>增大了计算量</li>
</ul>
<h3 id="其他反走样方法"><a href="#其他反走样方法" class="headerlink" title="其他反走样方法"></a>其他反走样方法</h3><ul>
<li>FXAA Fast Approximate AA<br>通过图像对比的方法,直接把锯齿换成没有锯齿</li>
<li>TAA Temporal AA<br>通过学习上一帧的图像,在静态中效果不错</li>
<li>Super Resolution /Super Sampling<br>把小图,低分辨率的图,拉大为高分辨率<br>DLSS(Deep Learning Super Sampling)</li>
</ul>
<h1 id="Lec7-shading-1"><a href="#Lec7-shading-1" class="headerlink" title="Lec7 shading 1"></a>Lec7 shading 1</h1><h2 id="visibility-occlusion"><a href="#visibility-occlusion" class="headerlink" title="visibility / occlusion"></a>visibility / occlusion</h2><p>由于z轴的存在,图像投射到2D上会有遮挡问题</p>
<h3 id="painter’s-algorithm"><a href="#painter’s-algorithm" class="headerlink" title="painter’s algorithm"></a>painter’s algorithm</h3><p>由远及近,对图像进行光栅化<br>paint from back to front</p>
<p>但对于这种情况,画家算法无能为力<br>哪个三角形在前,哪个在后,很难排<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231020202012.png" alt=""></p>
<h3 id="z-buffering"><a href="#z-buffering" class="headerlink" title="z-buffering"></a>z-buffering</h3><p>既然,对于三角形排序存在困难,那不如直接对像素进行排序<br>Idea:</p>
<ul>
<li>Store current min. z-value for each sample (pixel)</li>
<li>Needs an additional buffer for depth values<ul>
<li>frame buffer stores color values</li>
<li>depth buffer (z-buffer) stores depth<br>用两个buffer储存数据.一个存生成图像,一个存深度数据<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231020202547.png" alt=""></li>
</ul>
</li>
</ul>
<p>在这里,z的值一直都是正的,且越小越近,越大越远</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>先认定所有的三角形中的所有像素都会被画出来<br>通过zbuffer中的值判断<br>如果该像素是最近的,就更新framebuffer与zbuffer中的值<br>并且与画三角形的顺序无关<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Z-Buffer Algorithm</span></span><br><span class="line"><span class="comment">//Initialize depth buffer to ∞</span></span><br><span class="line"><span class="comment">//During rasterization:</span></span><br><span class="line"><span class="keyword">for</span> (each triangle T)</span><br><span class="line">  <span class="keyword">for</span> (each <span class="built_in">sample</span> (x,y,z) in T)</span><br><span class="line">    <span class="keyword">if</span> (z &lt; zbuffer[x,y]) <span class="comment">// closest sample so far</span></span><br><span class="line">      framebuffer[x,y] = rgb; <span class="comment">// update color</span></span><br><span class="line">      zbuffer[x,y] = z; <span class="comment">// update depth</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">  ; <span class="comment">// do nothing, this sample is occluded</span></span><br></pre></td></tr></table></figure></p>
<p>在GPU加速的情况下,性能非常好</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231020203357.png" alt=""></p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>$O(n)$复杂度</p>
<h4 id="深度相同如何处理"><a href="#深度相同如何处理" class="headerlink" title="深度相同如何处理"></a>深度相同如何处理</h4><p>没讲…</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>处理不了透明物体</p>
<h2 id="shading"><a href="#shading" class="headerlink" title="shading"></a>shading</h2><p>The process of applying a material to an object.<br>材质处理</p>
<p>shading is local<br>只看这个点的局部，不管光线的遮挡<br>不能实现阴影的生成<br>shading is different with shadow</p>
<h3 id="Blinn-Phong-reflectance-model"><a href="#Blinn-Phong-reflectance-model" class="headerlink" title="Blinn-Phong reflectance model"></a>Blinn-Phong reflectance model</h3><p>三种光线类型</p>
<ul>
<li>specular highlights</li>
<li>diffuse reflection</li>
<li>ambient lighting</li>
</ul>
<p>几个输入数据<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231020210500.png" alt=""></p>
<h4 id="diffuse-reflection-漫反射"><a href="#diffuse-reflection-漫反射" class="headerlink" title="diffuse reflection 漫反射"></a>diffuse reflection 漫反射</h4><h5 id="光接受能力"><a href="#光接受能力" class="headerlink" title="光接受能力"></a>光接受能力</h5><p>$\hat{l}$与$\hat{n}$的夹角决定能量的接受能力<br>计算时仅仅考虑单位面积<br>$\cos\theta=\hat{l}\cdot\hat{n}$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231020210914.png" alt=""></p>
<h5 id="光衰减"><a href="#光衰减" class="headerlink" title="光衰减"></a>光衰减</h5><p>把射出的光看作球壳,单位面积上的光强度为$I$<br>则对于距离点光源距离为$1$与$r$的球壳来说</p>
<script type="math/tex; mode=display">\begin{align*}
4\pi1^{2}I&=4\pi r^{2}I^\prime\\
I^{\prime}&=\frac{1}{r^{2}}
\end{align*}</script><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231020212758.png" alt=""></p>
<ul>
<li>$k_{d}$漫反射系数</li>
<li>$I/R^{2}$单位面积的能量</li>
<li>$max(0,\hat{n}\cdot\hat{l})$能量吸收率,若$\hat{n}\cdot\hat{l}$为负数,则值为0</li>
</ul>
<p>为什么与$v$没关系?<br>由于漫反射对于各个方向都一样,观察$v$在哪个位置没有区别，所以漫反射公式与$v$无关</p>
<h5 id="漫反射公式"><a href="#漫反射公式" class="headerlink" title="漫反射公式"></a>漫反射公式</h5><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231020221800.png" alt=""></p>
<h1 id="Lec8-shading2"><a href="#Lec8-shading2" class="headerlink" title="Lec8 shading2"></a>Lec8 shading2</h1><h2 id="shading-1"><a href="#shading-1" class="headerlink" title="shading"></a>shading</h2><h3 id="Blinn-Phong-reflectance-modeling"><a href="#Blinn-Phong-reflectance-modeling" class="headerlink" title="Blinn-Phong reflectance modeling"></a>Blinn-Phong reflectance modeling</h3><p>一个简化模型,与现实存在差距</p>
<h4 id="Specular-Term-高光"><a href="#Specular-Term-高光" class="headerlink" title="Specular Term 高光"></a>Specular Term 高光</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>it depends on the direction of your view<br>当观察角度$v$与镜面反射$R$足够接近的时候,才会观察到高光<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021180148.png" alt=""></p>
<h5 id="高光公式"><a href="#高光公式" class="headerlink" title="高光公式"></a>高光公式</h5><p>算法实现上,<br>判断$R$与$v$的接近程度$\Leftrightarrow$半程向量$\hat{h}$与法线向量$\hat{n}$的接近程度,这样就不需要计算镜面反射.半程向量实在是太好算</p>
<p>求$\hat{h}$只要用$\hat{l}+\hat{v}$,再归一化就行</p>
<p>$k_{s}$为镜面反射系数</p>
<p>为什么不考虑能量被吸收?<br>blinn-phong把这点简化了.</p>
<p>$max(0,\cos \alpha)$后面为什么会有一个指数?<br>$\cos \alpha$本身存在变化太慢的问题,不能够很好地表达高光情况,指数$p$越大,值变化更快,高光区域更小<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021181508.png" alt=""></p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021180417.png" alt=""></p>
<h4 id="ambient-term-环境光照"><a href="#ambient-term-环境光照" class="headerlink" title="ambient term 环境光照"></a>ambient term 环境光照</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>不依赖于任何东西<br>从任何一个角度看都一样,与$\hat{v}$无关<br>从实现效果来看就是进行最基础的颜色填充</p>
<p>This is approximate / fake!<br>$La = ka Ia$</p>
<h4 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h4><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021182440.png" alt=""></p>
<h3 id="shading-frequencies"><a href="#shading-frequencies" class="headerlink" title="shading frequencies"></a>shading frequencies</h3><p>在着色的时候存在精度问题<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021193346.png" alt=""></p>
<ul>
<li>flat shading<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021193455.png" alt=""></li>
<li>gouraud shading<br>shading each pixel<br>在每个顶点上进行着色<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021193720.png" alt=""></li>
<li>phong shading<br>shade each pixel<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021194326.png" alt=""></li>
</ul>
<h3 id="顶点法向量算法"><a href="#顶点法向量算法" class="headerlink" title="顶点法向量算法"></a>顶点法向量算法</h3><p>将$v$对应的法向量$n_{v}$视作与$v$有关的面所对应的法向量的和,再进行归一化<br>简单平均与加权平均都可以</p>
<script type="math/tex; mode=display">N_{v}={\frac{\sum_{i}N_{i}}{\|\sum_{i}N_{i}\|}}</script><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021195030.png" alt=""></p>
<h3 id="Barycentric-interpolation重心插值算法"><a href="#Barycentric-interpolation重心插值算法" class="headerlink" title="Barycentric interpolation重心插值算法"></a>Barycentric interpolation重心插值算法</h3><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021195000.png" alt=""></p>
<h2 id="Graphic-pipeline-实时渲染"><a href="#Graphic-pipeline-实时渲染" class="headerlink" title="Graphic pipeline 实时渲染"></a>Graphic pipeline 实时渲染</h2><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231023120129.png" alt=""></p>
<h3 id="shader"><a href="#shader" class="headerlink" title="shader"></a>shader</h3><p>用来定义对某个像素进行如何操作</p>
<p>编辑了一个基础的根据lambertian shading模型的DiffuseShader<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> myTexture;<span class="comment">// program parameter</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightDir;<span class="comment">// program parameter</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> uv;<span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec3</span> norm;<span class="comment">// per fragment value (interp. by rasterizer)</span></span><br><span class="line"><span class="type">void</span> diffuseShader()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">vec3</span> kd;</span><br><span class="line">&#125;</span><br><span class="line">kd = texture2d(myTexture, uv);<span class="comment">// material color from texture</span></span><br><span class="line">kd *= <span class="built_in">clamp</span>(<span class="built_in">dot</span>(–lightDir, norm), <span class="number">0.0</span>, <span class="number">1.0</span>);<span class="comment">// Lambertian shading model</span></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(kd, <span class="number">1.0</span>);<span class="comment">// output fragment color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以在shadertoy.com上联系观看别人的shader</p>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><p>并行度高,特别适合做图形学的运算<br>CPU并行计算能力差点意思</p>
<h2 id="texture-mapping"><a href="#texture-mapping" class="headerlink" title="texture mapping"></a>texture mapping</h2><p>模型本身是3D的,而他们的纹理是2D的.<br>要做到模型上的三角形对应到纹理上的三角形是很有难度的.<br>我们默认已知</p>
<h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><p>默认$u,v$大小都在$(0,1)$<br>模型上每个顶点都有一个对应的$(u,v)$坐标<br>且$(u,v)$坐标已知<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021203614.png" alt=""></p>
<h3 id="纹理的无缝衔接合成"><a href="#纹理的无缝衔接合成" class="headerlink" title="纹理的无缝衔接合成"></a>纹理的无缝衔接合成</h3><p>一种方案:Wang tile<br>可以依靠源砖,来产生相对较好的纹理,拼贴出的结果不会有太明显的重复，且没有周期性<br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%8E%8B%E6%B0%8F%E7%A0%96">wiki</a></p>
<h1 id="Lec9-shading3"><a href="#Lec9-shading3" class="headerlink" title="Lec9 shading3"></a>Lec9 shading3</h1><h2 id="Barycentric-coordinates"><a href="#Barycentric-coordinates" class="headerlink" title="Barycentric coordinates"></a>Barycentric coordinates</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h4 id="坐标角度"><a href="#坐标角度" class="headerlink" title="坐标角度"></a>坐标角度</h4><p>在任意的坐标系中,在一个三角形所在的平面上,已知三角形的三个点$A,B,C$,任意点$(x,y)$都可以用$(\alpha ,\beta ,\gamma)$来表示,并且和为1</p>
<script type="math/tex; mode=display">\begin{align}
&(x,y)=\alpha A+\beta Y+ \gamma C\\
&\alpha + \beta +\gamma=1
\end{align}</script><p>注意:</p>
<ol>
<li>在三角形内部,要求$\alpha ,\beta ,\gamma \geq0$</li>
<li>由于$\alpha + \beta +\gamma=1$的特性,知道$\alpha \beta \gamma$中的任意两个就可以求得另外一个,未知数其实为2个<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021215702.png" alt=""><br>$A=(1,0,0)$<br>$B=(0,1,0)$<br>$C=(0,0,1)$</li>
</ol>
<h4 id="几何角度"><a href="#几何角度" class="headerlink" title="几何角度"></a>几何角度</h4><p>从面积的角度求重心坐标<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231021220147.png" alt=""></p>
<p>不用去记<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231024202058.png" alt=""></p>
<h3 id="using-Barycentric-coordinates"><a href="#using-Barycentric-coordinates" class="headerlink" title="using Barycentric coordinates"></a>using Barycentric coordinates</h3><h4 id="Linearly-interpolate-values"><a href="#Linearly-interpolate-values" class="headerlink" title="Linearly interpolate values"></a>Linearly interpolate values</h4><p>对于任何一个点,已知其重心坐标$(\alpha,\beta,\gamma)$,可以计算出该点的属性值，例如颜色，亮度，向量等等</p>
<script type="math/tex; mode=display">V=\alpha V_{a}+\beta V_{b}+\gamma V_{c}</script><p>可以在投影之前3D空间中的三角形做线性插值，经过投影之后不行<br>但可以通过逆变换，将二维的三角形变为三维的三角形，再做插值<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231024202443.png" alt=""></p>
<h4 id="Texture-Mapping"><a href="#Texture-Mapping" class="headerlink" title="Texture Mapping"></a>Texture Mapping</h4><p>在原来的纹理中,只有三角形顶点的坐标<br>而经过重心坐标的处理之后,texture中的每一个点$(u,v)$都可以用$\alpha A+\beta Y+ \gamma C$表示<br>只要在texture上对$(u,v)$进行查询,就可以知道该点对应的纹理的信息(颜色,亮度等等)</p>
<p>从而可以知道在经过光栅化之后的显示器上显示的效果<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231024204233.png" alt=""></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="texture-magnification"><a href="#texture-magnification" class="headerlink" title="texture magnification"></a>texture magnification</h3><h4 id="small-case"><a href="#small-case" class="headerlink" title="small case"></a>small case</h4><p>如果纹理太小了,将到较大的屏幕映射到较小的纹理上有问题.<br>大集合映射到小集合上,会出现大集合中的多个元素同时映射到小集合的同一个元素上.<br>从观感上来说,是纹理放大,用一张画去贴图整个墙面,把画放大之后再去贴<br>几种处理方式:</p>
<ul>
<li>nearest</li>
<li>bilinear</li>
<li>bicubic</li>
</ul>
<p>从效果上来看,bicubic最好,bilinear不错,差距主要在眼角的位置.但是bicubic性能开销大<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025190946.png" alt=""></p>
<h5 id="nearest"><a href="#nearest" class="headerlink" title="nearest"></a>nearest</h5><p>将pixel坐标映射到纹理坐标上,选择最近的纹理顶点<br>如图,选择$u11$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025202019.png" alt=""></p>
<p><code>疑问:既然前面介绍了重心坐标,可以计算texture上每一个点的属性,为什么还要用这种方法?</code><br>和采用的纹理本身有关.这里使用的纹理是由是纹素组成</p>
<h5 id="线性插值-bilinear-interpolation"><a href="#线性插值-bilinear-interpolation" class="headerlink" title="线性插值 bilinear interpolation"></a>线性插值 bilinear interpolation</h5><p>linear interpolation 公式:</p>
<script type="math/tex; mode=display">\begin{align}
lerp(x,v_{0},v_{1})&=v_{0}+x(v_{1}-v_{0})\\
x&\in(0,1)
\end{align}</script><p>对于这幅图来说<br>从红点的位置可以推算出来两个单线性插值</p>
<script type="math/tex; mode=display">\begin{align}
u_{0}&=lerp(s,u_{00},u_{10})\\
u_{1}&=lerp(s,u_{01},u_{11})\\
\end{align}</script><p>两个单线性插值能够计算出$u_{1},u_{0}$<br>再根据$u_{1},u_{0}$再进行一次插值</p>
<script type="math/tex; mode=display">f(x,y)=lerp(t,u_{0},u_{1})</script><p>这就是双线性插值,从步骤上看,<br>第一次插值:四个点插值为两个点<br>第二次插值:两个点插值为一个点<br>双线性对应的是$2^{2}$的指数$2$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025191959.png" alt=""></p>
<h5 id="bicubic"><a href="#bicubic" class="headerlink" title="bicubic"></a>bicubic</h5><p>性能开销太大,效果最好</p>
<h3 id="big-case"><a href="#big-case" class="headerlink" title="big case"></a>big case</h3><p>texture太大,而screen太小<br>一个像素对应的texture范围过大,会造成走样.<br>从信号的角度看,单个像素对应的texel中,内容变换过快,信号变化频率高,而采样次数太少,从而产生了走样<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025203735.png" alt=""></p>
<p>传统方法处理最右边的情况效果就很差了<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025204219.png" alt=""></p>
<p>处理方式:</p>
<ul>
<li>super-samping</li>
<li></li>
</ul>
<h4 id="super-Sampling"><a href="#super-Sampling" class="headerlink" title="super Sampling"></a>super Sampling</h4><p>例如单个像素中采样512次,通过提高采样频率避免走样<br>但是对性能消耗太高</p>
<h4 id="range-query"><a href="#range-query" class="headerlink" title="range query"></a>range query</h4><p>既然采样会出现走样的问题,那我就不采样了😡<br>对于一个像素包含大范围的texture的情况,进行range query<br>获取某一像素下对应的纹理区域颜色<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025210604.png" alt=""></p>
<h5 id="mipmap"><a href="#mipmap" class="headerlink" title="mipmap"></a>mipmap</h5><h6 id="what-is-mipmap"><a href="#what-is-mipmap" class="headerlink" title="what is mipmap"></a>what is mipmap</h6><p>Allowing <code>(fast, approximate, square)</code> range queries<br>仅限于正方形,被操作对象为texture<br>“Mip” comes from the Latin “multum in parvo”, meaning a multitude in a small space</p>
<p>以原图为$n \times n$为例<br>在原图的基础上,削减像素数量,为原来的一半,最后图像$level=log_{2}n$.,例如当$n=128$时,最终图为$level 7$<br>从性能开销上来看,储存仅仅为原来的$\frac{4}{3}$</p>
<script type="math/tex; mode=display">1^{2}+2^{2}+ \ldots+(\frac{n}{2})^{2}+n^{2}=\frac{4}{3}n^{2}</script><p>mipmap的生成是在range query之前完成<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025210710.png" alt=""></p>
<p>左边为屏幕像素,右边为纹理上的texel<br>如果要对点$(u,v)_{00}$进行mipmap计算<br>找到这个点周围距离为一个pixel的几个点,计算它们的textue坐标.再计算中心点与周围点的距离,用最大的$L$值画一个正方形,进行range query<br>查询的图像的$level=log_{2}L$.<br>一个像素对应的$L \times L$texel.既然已经对纹理进行过mipmap的操作,那就可以在对应level上查询到$L \times L$的范围内的颜色.<br>例如,当$L=4$的时候,$level=2$,只要查询$level_{2}$上$(u,v)$坐标对应的块的数据就行<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025212345.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025212712.png" alt=""></p>
<h6 id="trilinear-interpolation-三线性插值"><a href="#trilinear-interpolation-三线性插值" class="headerlink" title="trilinear interpolation 三线性插值"></a>trilinear interpolation 三线性插值</h6><p>根据不同位置查询的层数的值进行渲染.<br>但也有这不理想的地方.因为mipmap生成的图是离散的,导致,查询的层数是离散的,两个相邻的像素点,一个查询1,一个查询2,可能结果图像会有一条缝隙,做不到查询1.8层.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025214840.png" alt=""></p>
<p>优化方法:<br>三线性插值法<br>trilinear interpolation</p>
<p>查询相邻的两个level的mipmap,对D level进行一次bilinear interpolation,对D+1 level也进行一次bilinear interpolation.最后对双线性插值的结果进行线性插值.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025215451.png" alt=""></p>
<p>效果非常漂亮<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025215814.png" alt=""></p>
<p>三线性插值在游戏中经常用到,可以自己开关试试效果</p>
<h6 id="overblur问题"><a href="#overblur问题" class="headerlink" title="overblur问题"></a>overblur问题</h6><p>mipmap本身还是存在问题,因为查询的是像素对应的texture范围上的颜色,所以会出现模糊<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025220358.png" alt=""></p>
<p>pixel应该对应的范围是矩形,而mipmap算法用square对应,差错就会很大了<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025220808.png" alt=""></p>
<h6 id="Anisotropic-Filtering各向异性过滤"><a href="#Anisotropic-Filtering各向异性过滤" class="headerlink" title="Anisotropic Filtering各向异性过滤"></a>Anisotropic Filtering各向异性过滤</h6><p>各向异性:各个方向上表现不同</p>
<p>这时候就需要我各向异性过滤来优化,效果很不错<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025220536.png" alt=""></p>
<p>沿着图像对角线为mipmap,横向为横向压缩图,纵向为纵向压缩图<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025220629.png" alt=""></p>
<p>游戏中,各项异性过滤有不同的层数,例如4层,16层等.但是实际上,改变各项异性层数对于性能开销不大.<br>层数代表在各个方向上运算的次数.2层表示各个方向上压缩两次,<br>开销为:<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025222028.png|483" alt=""><br>而4层,<br>开销为:<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025222241.png|525" alt=""><br>差距非常小<br>一旦开启各向异性,层数区别不大,并且,无限层的开销趋向于原来的三倍.显存够,开最高就行<br><img src="2023-10-25-22-24-10.png|625" alt=""></p>
<p>可以根据ripmaps查询,比较好处理蓝色的矩形,但对于红色的斜矩形,效果还是差<br><img src="2023-10-25-22-07-53.png" alt=""></p>
<p>可以用EWA方法进行优化<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231025221814.png" alt=""></p>
<h2 id="Applications-of-textures"><a href="#Applications-of-textures" class="headerlink" title="Applications of textures"></a>Applications of textures</h2><p>In modern GPUs, texture = memory + range query (filtering).<br>纹理就是一些内存,使用内存就是内存查询的过程.</p>
<h3 id="Environment-Map"><a href="#Environment-Map" class="headerlink" title="Environment Map"></a>Environment Map</h3><p>你能看到的任何东西都有光照信息</p>
<p>用纹理描述环境光照<br>将环境光照的texture贴到茶壶上.<br>光照最好有方向和距离两个定义,单单方向会有问题.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028153320.png" alt=""></p>
<h4 id="Spherical-Environment-Map"><a href="#Spherical-Environment-Map" class="headerlink" title="Spherical Environment Map"></a>Spherical Environment Map</h4><p>将环境光记录在球体上<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028154304.png" alt=""><br>好处在于,方便查询,任意方向的光线,直接在球体上找对应的方向就行,但也有问题</p>
<p>像世界地图一样,上方和下方会有扭曲<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028154421.png" alt=""></p>
<h4 id="Cube-Map"><a href="#Cube-Map" class="headerlink" title="Cube Map"></a>Cube Map</h4><p>用立方体描述环境光<br>好处在于图像展开没有变形<br>坏处在于,查询的时候,需要计算下方向才能查找到正确的点<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028154724.png" alt=""></p>
<h2 id="Bump-map"><a href="#Bump-map" class="headerlink" title="Bump map"></a>Bump map</h2><p>如何实现凹凸不平的表面效果?<br>model可以是一个光滑的球体,而贴图采用凹凸贴图.凹凸贴图上记录一个相对高度信息,或者一个新的法向量,来实现凹凸的shading效果.从而欺骗眼睛.<br>用复杂的贴图代替复杂的模型<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028155432.png" alt=""></p>
<h4 id="凹凸贴图法向量计算"><a href="#凹凸贴图法向量计算" class="headerlink" title="凹凸贴图法向量计算"></a>凹凸贴图法向量计算</h4><p>使用凹凸贴图后的表面<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028161502.png" alt=""></p>
<h5 id="1D-贴图"><a href="#1D-贴图" class="headerlink" title="1D 贴图"></a>1D 贴图</h5><p>flatland<br>求导求切线,再对切线变换,算出向量<br>注意要对向量进行归一化操作<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028161613.png" alt=""></p>
<h5 id="2D-贴图"><a href="#2D-贴图" class="headerlink" title="2D 贴图"></a>2D 贴图</h5><p>处理2D贴图,默认原来表面的向量为(0,0,1)</p>
<p>2D texture上有两个方向,$u,v$,对两个方向分别求导,<br>再取负数,可得到法向量<br>注意归一化<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028161730.png" alt=""></p>
<h2 id="displacement-mapping"><a href="#displacement-mapping" class="headerlink" title="displacement mapping"></a>displacement mapping</h2><p>会去真的移动几何结构,例如移动顶点<br>为了弥补bump map的缺点,在图像边缘,和由于本身高度变换带来的阴影显示效果不好</p>
<p>需要足够精细的模型<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028163001.png" alt=""></p>
<h2 id="3D纹理"><a href="#3D纹理" class="headerlink" title="3D纹理"></a>3D纹理</h2><p>定义一个三维的纹理,劈开之后还能看到内部的纹理<br>实际上并没有纹理,而是一个三维噪声函数,通过一系列的操作,可以得到图形<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028163017.png" alt=""></p>
<h2 id="记录信息"><a href="#记录信息" class="headerlink" title="记录信息"></a>记录信息</h2><p>Provide Precomputed shading<br>先计算好环境光遮蔽,再存储到texture中.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028163441.png" alt=""></p>
<h2 id="3D-Textures-and-Volume-Rendering"><a href="#3D-Textures-and-Volume-Rendering" class="headerlink" title="3D Textures and Volume Rendering"></a>3D Textures and Volume Rendering</h2><p>三维的纹理<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231028163518.png" alt=""></p>
<h1 id="Lec10-Geometry1-Introduction-to-Geometry"><a href="#Lec10-Geometry1-Introduction-to-Geometry" class="headerlink" title="Lec10 Geometry1 Introduction to Geometry"></a>Lec10 Geometry1 Introduction to Geometry</h1><h2 id="隐式几何-implicit"><a href="#隐式几何-implicit" class="headerlink" title="隐式几何 implicit"></a>隐式几何 implicit</h2><p>做光线追踪方便</p>
<h3 id="Algebraic-Surfaces"><a href="#Algebraic-Surfaces" class="headerlink" title="Algebraic Surfaces"></a>Algebraic Surfaces</h3><p>通过对点进行分类,实现的隐式表达.<br>例如对于球体$x^{2}+y^{2}+z^{2}=1$,对点进行分类,分成符合该式子,与不符合.$(x,y,z)$这个点就是我定义的球体表面上的点.</p>
<p>便于判断某个点在不在面上,但不好列举哪些点在面上,从而不便推断出图像的样子</p>
<p>不好采样<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104152011.png" alt=""></p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104152746.png" alt=""></p>
<h3 id="Constructive-Solid-Geometry-Implicit"><a href="#Constructive-Solid-Geometry-Implicit" class="headerlink" title="Constructive Solid Geometry (Implicit)"></a>Constructive Solid Geometry (Implicit)</h3><p>CSG方式<br>对隐式表达进行布尔运算<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104152830.png" alt=""></p>
<h3 id="signed-distance-function"><a href="#signed-distance-function" class="headerlink" title="signed distance function"></a>signed distance function</h3><p>表示能力非常强大</p>
<p>求空间中,各个点到边界的距离,并且是有方向的距离(signed).<br>blend距离,就等于blend他们的边界<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104153724.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104153920.png" alt=""></p>
<h3 id="level-set-水平集描述"><a href="#level-set-水平集描述" class="headerlink" title="level set 水平集描述"></a>level set 水平集描述</h3><p>从用distance function生成的数据集中,使用插值的方法,找到$f(x)=0$的线,绘制出$f(x)=0$的表面<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104160029.png" alt=""></p>
<p>医疗数据,组织密度渲染<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104160215.png" alt=""><br>物理仿真<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104160256.png" alt=""></p>
<h3 id="fractals-分形法"><a href="#fractals-分形法" class="headerlink" title="fractals 分形法"></a>fractals 分形法</h3><p>类似万花筒,细节非常到位,但控制它生成什么形状存在困难<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104211023.png" alt=""></p>
<h2 id="显式几何-explicit"><a href="#显式几何-explicit" class="headerlink" title="显式几何 explicit"></a>显式几何 explicit</h2><p>直接定义或是参数定义</p>
<h3 id="直接"><a href="#直接" class="headerlink" title="直接"></a>直接</h3><p>直接告诉三角形的各个坐标,来显式构造球体,</p>
<h3 id="参数映射的方式"><a href="#参数映射的方式" class="headerlink" title="参数映射的方式"></a>参数映射的方式</h3><p>对于二维平面$(u,v)$上的各个点,通过一个函数$f$映射到三维空间中,实现显式构造<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104151725.png" alt=""><br>采样非常方便,判断里外艰难<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104152028.png" alt=""></p>
<h3 id="point-cloud"><a href="#point-cloud" class="headerlink" title="point cloud"></a>point cloud</h3><p>一个$(x,y,z)$的列表就行,是最简单的方法,<br>绘制对采样的精度要求高.精度过低,效果不好,<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104211155.png" alt=""></p>
<h3 id="polygon-mesh"><a href="#polygon-mesh" class="headerlink" title="polygon mesh"></a>polygon mesh</h3><p>应用最为广泛的图形表达方式<br>对各种操作的支持度都不错.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104211316.png" alt=""></p>
<h2 id="obj格式"><a href="#obj格式" class="headerlink" title=".obj格式"></a>.obj格式</h2><p>v 储存点信息<br>vt储存纹理<br>vn储存法向量</p>
<p>f为v/vt/vn</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231104211711.png" alt=""></p>
<h1 id="Lec11-Curves-and-Surfaces"><a href="#Lec11-Curves-and-Surfaces" class="headerlink" title="Lec11 Curves and Surfaces"></a>Lec11 Curves and Surfaces</h1><h2 id="Bezier-Curves-贝塞尔曲线"><a href="#Bezier-Curves-贝塞尔曲线" class="headerlink" title="Bézier Curves 贝塞尔曲线"></a>Bézier Curves 贝塞尔曲线</h2><h3 id="Bezier-Curves-之-de-Casteljau-算法"><a href="#Bezier-Curves-之-de-Casteljau-算法" class="headerlink" title="Bézier Curves 之 de Casteljau 算法"></a>Bézier Curves 之 de Casteljau 算法</h3><p>进行递归运算,一次减少一个点,最后一个点的轨迹就是该算法得到的贝塞尔曲线<br>使用的是显式几何,引入时间参数$t$,$t\in(0,1)$,来定义贝塞尔曲线<br>先找到在$t$时间,$b_{0},b_{1}$之间的点$b_{0}^{1}$,<br>同理得到$b_{1}^{1},b_{2}^{1}$<br>再处理$t$时间$b_{0}^{1},b_{1}^{1},b_{2}^{1}$三点,得到$b_{0}^{2},b_{1}^{2}$<br>最后同理得到$t$时间的$b_{0}^{3}$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231105142852.png" alt=""></p>
<p>从流程的图来看,<br>a,b,c,d为控制点<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231105142930.png" alt=""></p>
<h3 id="数学定义"><a href="#数学定义" class="headerlink" title="数学定义"></a>数学定义</h3><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106195554.png" alt=""></p>
<p>总共有$n+1$个点<br>$b^{n}(t)$为表达最终生成点$b_{0}^{n}(t)$的$n$次多项式.<br>$B_{j}^{n}(t)$是伯恩斯坦多项式</p>
<script type="math/tex; mode=display">\begin{align}
b^{n}(t)&=b_{0}^{n}(t)=\sum^{n}_{j=0}b_{j}B_{j}^{n}(t)\\
B_{i}^{n}(t)&=\ {\binom{n}{i}}t^{i}(1-t)^{n-i}
\end{align}</script><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106195755.png" alt=""></p>
<p>对于四个控制点的贝塞尔曲线应用<br>${\bf b}^{n}(t)={\bf b}_{0}\,(1-t)^{3}+{\bf b}_{1}\,3t(1-t)^{2}+{\bf b}_{2}\,3t^{2}(1-t)+{\bf b}_{3}\,t^{3}$</p>
<p>伯恩斯坦方程具有对称性<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106200742.png" alt=""></p>
<h3 id="Properties-of-Bezier-Curves"><a href="#Properties-of-Bezier-Curves" class="headerlink" title="Properties of Bézier Curves"></a>Properties of Bézier Curves</h3><p>例子中是四个控制点$b_{0},b_{1},b_{2},b_{3}$的三维贝塞尔曲线<br>三维贝塞尔曲线,起点是$b_{0}$,终点是$b_{3}$<br>在控制点的切线是$b^\prime(n)=3(b_{n+1}-b_{n})$,系数一定为3<br>对于仿射变换具有良好性质.控制点直接生成的贝塞尔曲线经过仿射变换,和仿射变换之后的控制点生成的贝塞尔曲线,一摸一样,但对于其他的变换不适用<br>具有凸包性质.生成的贝塞尔曲线一定在控制点形成的闭包之内.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106200846.png" alt=""></p>
<h4 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h4><p>最外面的一个圈就是</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106201637.png" alt=""></p>
<h3 id="Piecewise-Bezier-Curves-分段贝塞尔曲线"><a href="#Piecewise-Bezier-Curves-分段贝塞尔曲线" class="headerlink" title="Piecewise Bézier Curves 分段贝塞尔曲线"></a>Piecewise Bézier Curves 分段贝塞尔曲线</h3><p>对于这样的控制点,生成的贝塞尔曲线,难以控制,并且生成难度高<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106203913.png" alt=""></p>
<p>所以人们选择分段生成贝塞尔曲线<br>每段由四个控制点生成<br>衔接的地方不一定平滑<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106204004.png" alt=""></p>
<p>为了描述平滑的情况,提出了不同级别的continuity</p>
<ul>
<li>$C^{0}$  continuity<br>几何上的连续<br>两段贝塞尔曲线都经过红点<br>前段结束点为后段起始点<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106204646.png" alt=""></li>
<li>$C^{1}$  continuity<br>公共点为左右两点的中点时<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106204658.png" alt=""></li>
</ul>
<h2 id="其他曲线"><a href="#其他曲线" class="headerlink" title="其他曲线"></a>其他曲线</h2><h3 id="splines-样条"><a href="#splines-样条" class="headerlink" title="splines 样条"></a>splines 样条</h3><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106205407.png" alt=""></p>
<p>有与分段贝塞尔曲线类似的性质,并且更可控.但也更难计算<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106205427.png" alt=""></p>
<h2 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h2><p>贝塞尔曲面<br>用$4\times4$的控制点,两个时间参数$(u,v)$生成<br>在时间$u$下,每组控制点生成一个新的点,共计四个新点<br>四个新点在时间$v$下生成新的点,贝塞尔曲面点<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106212501.png" alt=""></p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106212512.png" alt=""></p>
<h2 id="mesh"><a href="#mesh" class="headerlink" title="mesh"></a>mesh</h2><p>三大主题</p>
<ul>
<li>subdivision 网格细分</li>
<li>simplification 网格化简</li>
<li>regularization 网格正规化,尽量接近正三角形,大小接近</li>
</ul>
<h1 id="Lec12-geometry3-mesh"><a href="#Lec12-geometry3-mesh" class="headerlink" title="Lec12 geometry3 mesh"></a>Lec12 geometry3 mesh</h1><h2 id="subdivision"><a href="#subdivision" class="headerlink" title="subdivision"></a>subdivision</h2><h3 id="loop-subdivision"><a href="#loop-subdivision" class="headerlink" title="loop subdivision"></a>loop subdivision</h3><p>loop与循环没关系,发明这个的人姓loop<br>First, create more triangles(vertices)<br>Second, tune their positions<br>先细分再调整位置<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106231652.png" alt=""></p>
<ul>
<li><p>对于新vertices<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106231749.png" alt=""></p>
</li>
<li><p>对于旧vertices<br>根据原来点的度来选择权重<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106231839.png" alt=""></p>
</li>
</ul>
<h3 id="catmull-clark-subdivision"><a href="#catmull-clark-subdivision" class="headerlink" title="catmull-clark subdivision"></a>catmull-clark subdivision</h3><p>适用于四边形网格.<br>奇异点:degree != 4<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106234258.png" alt=""></p>
<p>每有一个非四边形,就会产生一个新的奇异点.<br>取非四边形的边的中点,再选择一个点与他们相连,破坏原有的非四边形,生成四边形,与一个新的奇异点<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106234308.png" alt=""></p>
<p>调整各个vertice的权重计算<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231106234533.png" alt=""></p>
<h2 id="mesh-simplification"><a href="#mesh-simplification" class="headerlink" title="mesh simplification"></a>mesh simplification</h2><h3 id="edge-collapse-边坍缩"><a href="#edge-collapse-边坍缩" class="headerlink" title="edge collapse 边坍缩"></a>edge collapse 边坍缩</h3><p>使用二次度量误差算法Quadric Error Metrics</p>
<p>简单对原来的点求平均的简化算法不够好,提出了二次度量误差算法<br>二次:点到平面的距离的平方<br>要求新的位置到原来各个面的距离的平方和最小</p>
<script type="math/tex; mode=display">\min(\sum_{i=1}^{n}distance^{2})</script><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107000238.png" alt=""></p>
<p>二次度量误差的数据结构采用堆(优先队列),能够迅速查询最小值,也能够快速更新</p>
<p>先对最小值的边进行坍缩,更新堆,再对最小值的边进行坍缩.贪心算法</p>
<p>局部最优!=全局最优,但在绝大部分情况下,这样的贪心算法效果很好<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107000859.png" alt=""></p>
<h2 id="shadow-mapping"><a href="#shadow-mapping" class="headerlink" title="shadow mapping"></a>shadow mapping</h2><p>只能处理点光源,只能生成硬阴影(边界没有颜色过度,非常锐利)<br>点光源没有大小,只是一个点</p>
<p>原图<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107134703.png" alt=""></p>
<ol>
<li>记录从点光源方向看去的深度图<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107134720.png" alt=""></li>
<li>从相机或人眼看过去的点的深度<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107134645.png" alt=""></li>
<li>比较1,2的深度,来判断是否生成shadow mapping<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107134621.png" alt=""></li>
</ol>
<p>浮点数本身的比较存在困难.判断浮点数是否相等,被精度问题困扰,比较难.<br>method:</p>
<ul>
<li>判断 from eye’s 大于 from light’s,就生成shadow mapping</li>
<li>引入bias,若from eye’s大于 from light’s + bias,就生成shadow mapping</li>
</ul>
<h4 id="problem-with-shadow-mapping"><a href="#problem-with-shadow-mapping" class="headerlink" title="problem with shadow mapping"></a>problem with shadow mapping</h4><ul>
<li>Hard shadows (point lights only)</li>
<li>Quality depends on shadow map resolution(general problem with image-based techniques) 不同的分辨率最后的阴影结果不同</li>
<li>Involves equality comparison of floating point depth values means issues of scale, bias, tolerance</li>
</ul>
<h1 id="Lec13-ray-tracing-1"><a href="#Lec13-ray-tracing-1" class="headerlink" title="Lec13 ray tracing 1"></a>Lec13 ray tracing 1</h1><p>光线追踪是另一种成像方式.<br>主要是为了解决rasterization上的<br>不足:</p>
<ul>
<li>soft shadow</li>
<li>光的二次,多次反射<ul>
<li>间接光照</li>
<li>glossy reflection</li>
</ul>
</li>
<li><p>质量低<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107152740.png" alt=""></p>
</li>
<li><p>Ray tracing is <code>accurate</code>, but is very <code>slow</code></p>
</li>
<li>Rasterization: <code>real-time</code>(每秒至少30frame), ray tracing: <code>offline</code></li>
</ul>
<h2 id="Basic-Ray-Tracing-Algorithm"><a href="#Basic-Ray-Tracing-Algorithm" class="headerlink" title="Basic Ray-Tracing Algorithm"></a>Basic Ray-Tracing Algorithm</h2><p>三条定义</p>
<ul>
<li>光以直线传播,忽略波动性</li>
<li>与其他光线碰撞不会发生交互</li>
<li>光线从光源到眼睛(工程上的实现与这个恰好相反,光路可逆性的应用)</li>
</ul>
<h3 id="ray-casting算法"><a href="#ray-casting算法" class="headerlink" title="ray casting算法"></a>ray casting算法</h3><p>仅仅考虑了光的一次发射,没有考虑多次反射的光线</p>
<ol>
<li>从每个像素发出光线</li>
<li>判断物体与光线的交点,与光源的连线是否有遮挡,判断阴影情况<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107154727.png" alt=""></li>
</ol>
<ul>
<li>Pinhole Camera Model<br>根据与光源的相对情况给进行着色<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107154938.png" alt=""><h3 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive (Whitted-Style) Ray Tracing"></a>Recursive (Whitted-Style) Ray Tracing</h3>对光线进行多次递归运算,再进行shading.<br>光线名称做出分类:</li>
<li>primary ray</li>
<li>secondary ray</li>
<li>shadow ray<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107161111.png" alt=""><br>效果也不错<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107161222.png" alt=""></li>
</ul>
<h3 id="Ray-Surface-Intersection-交点"><a href="#Ray-Surface-Intersection-交点" class="headerlink" title="Ray-Surface Intersection (交点)"></a>Ray-Surface Intersection (交点)</h3><p>光线由三个参数来定义.<br>t为时间 o为原点 d为单位方向向量<br>光线被定义为射线,只有一个方向</p>
<script type="math/tex; mode=display">r(t)=o+td,0\leq t <\infty</script><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107164323.png" alt=""></p>
<h4 id="Ray-Intersection-With-Sphere"><a href="#Ray-Intersection-With-Sphere" class="headerlink" title="Ray Intersection With Sphere"></a>Ray Intersection With Sphere</h4><p>简单的数学运算<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107164606.png" alt=""></p>
<h4 id="Ray-Intersection-With-Implicit-Surface"><a href="#Ray-Intersection-With-Implicit-Surface" class="headerlink" title="Ray Intersection With Implicit Surface"></a>Ray Intersection With Implicit Surface</h4><p>计算可以用各种方法实现:</p>
<ul>
<li>利用包,数学运算库</li>
<li>利用试点,优化法<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107164626.png" alt=""></li>
</ul>
<h4 id="Ray-Intersection-With-Triangle-Mesh-最常见的显式表面"><a href="#Ray-Intersection-With-Triangle-Mesh-最常见的显式表面" class="headerlink" title="Ray Intersection With Triangle Mesh (最常见的显式表面)"></a>Ray Intersection With Triangle Mesh (最常见的显式表面)</h4><p>对于给定的mesh与光线,遍历全部三角形求交点.忽略完全平行的请况.<br>简单但是效率低下<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107165012.png" alt=""></p>
<p>inside与outside判断:<br>给定一个封闭图形(2D,3D都行),判断一个点是否再图形内部中,从该点射出一条射线,<br>if(交点数量为奇数)<br>  在图形内部<br>else if(交点数量为偶数)<br>  在图形外部<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107165420.png" alt=""></p>
<h5 id="平面计算化简法"><a href="#平面计算化简法" class="headerlink" title="平面计算化简法"></a>平面计算化简法</h5><p>先算平面与光线的交点,再算交点是否在三角形内<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107170452.png" alt=""></p>
<p>平面的定义:<br>一个平面法向量$N$与平面上的一个点$P^{\prime}$<br>平面是点的集合,根据式子</p>
<script type="math/tex; mode=display">p:(p-p^{\prime})\cdot{N}=0</script><p>来定义平面<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107170513.png" alt=""><br>对于平面上的这个点,它既在面上,又在射线上<br>联立方程可解<br>最后要检查,要求$0 \leq t &lt; \infty$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107170724.png" alt=""></p>
<h5 id="Moller-Trumbore-Algorithm-直接求交"><a href="#Moller-Trumbore-Algorithm-直接求交" class="headerlink" title="Möller Trumbore Algorithm 直接求交"></a>Möller Trumbore Algorithm 直接求交</h5><p>用上克拉默法则<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107171427.png" alt=""></p>
<h4 id="Accelerating-Ray-Surface-Intersection"><a href="#Accelerating-Ray-Surface-Intersection" class="headerlink" title="Accelerating Ray-Surface Intersection"></a>Accelerating Ray-Surface Intersection</h4><p>每一个像素发出一条射线,每条射线要与每个objects计算,效果非常差<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107172144.png" alt=""></p>
<h5 id="Bounding-Volumes-包围盒"><a href="#Bounding-Volumes-包围盒" class="headerlink" title="Bounding Volumes 包围盒"></a>Bounding Volumes 包围盒</h5><p>将需要计算交点的物体,用包围盒包起来.包围盒一般都是比较简单的物体.长方形,长方体等等<br>长方体包围盒由三对相对的面来定义<br>AABB 包围盒,要求与每个面直角坐标系的某个平面平行,<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107172649.png" alt=""></p>
<p>AABB好处在于,计算时间$t$非常简单<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107174301.png" alt=""></p>
<p>bounding box本身是由几对面求∩表达<br>光线在bounding box内的时间也是如此<br>先对各对面,求光线进入时间$t_{min}$,出去时间$t_{max}$.<br>再求交集,就是对<br>所有的$t_{min}$求最大值 $max(t_{min})$<br>所有的$t_{max}$求最小值 $min(t_{max})$<br>暂时不考虑$t_{min}&lt;0$的处理<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107174346.png" alt=""></p>
<script type="math/tex; mode=display">\begin{align}
t_{enter}=max(t_{min})\\
t_{exit}=min(t_{min})
\end{align}</script><p>iff意为当且仅当<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107175015.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107175244.png" alt=""></p>
<h1 id="Lec14-ray-tracing-2-Acceleration-amp-Radiometry"><a href="#Lec14-ray-tracing-2-Acceleration-amp-Radiometry" class="headerlink" title="Lec14 ray tracing 2 Acceleration &amp; Radiometry"></a>Lec14 ray tracing 2 Acceleration &amp; Radiometry</h1><p>传统的ray tracing算法开销太大,要进行加速优化<br>Using AABBs to accelerate ray tracing</p>
<h2 id="Uniform-grids"><a href="#Uniform-grids" class="headerlink" title="Uniform grids"></a>Uniform grids</h2><p>在分布均匀的图像中表现较好<br>不均匀的图像中,表现差</p>
<p>形成规则网格,来加速<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107215715.png" alt=""></p>
<p>对每个小格子进行相交判断.<br>if(与盒子相交)<br>  计算与物体相交情况<br>else<br>  跳过</p>
<p>通过盒子不一定与物体有交点<br>不通过盒子与物体一定没有交点<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107215746.png" alt=""></p>
<p>但盒子的分辨率会导致加速效果.<br>盒子太少,每个盒子都要计算与物体相交情况<br>盒子太多,要对每个盒子计算是否相交</p>
<p>最好的盒子数量约为 物体数量的27倍<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107220431.png" alt=""></p>
<h3 id="Spatial-Partitions-空间划分"><a href="#Spatial-Partitions-空间划分" class="headerlink" title="Spatial Partitions 空间划分"></a>Spatial Partitions 空间划分</h3><ul>
<li>oct-tree 八叉树<br>在d维度下为n叉树,$n=2^{d}$.<br>该特性导致n叉树实际效果不太好,尤其是在高维的情况下.划分难度高,性能要求高</li>
<li>kd-tree<br>总体来说最好的空间划分方式.运用二叉树与AABB的思想.每次划分一刀,每刀方向不同,但与轴align.例如在二维平面中,先横切,再对每个部分竖切.</li>
<li>BSP-tree<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107220607.png" alt=""></li>
</ul>
<h4 id="kd-tree"><a href="#kd-tree" class="headerlink" title="kd-tree"></a>kd-tree</h4><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107221156.png" alt=""></p>
<p>内部节点与叶子节点的数据结构<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107221238.png" alt=""></p>
<p>类似于二分查找,对每一个叶子节点求是否相交<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107223017.png" alt=""></p>
<p>但kd-tree本身也有一些缺陷</p>
<ul>
<li>某个物体可能被多个AABB划分,导致每个AABB对应的叶子节点中都要储存这个物体的信息</li>
<li>给出一个包围盒很难判定它和哪些三角形有交集，也是这个原因最近10年渐渐不用KD树的方法了<br>为解决,引入Object Partitions 物体划分 Bounding Volume Hierarchy (BVH)</li>
</ul>
<h2 id="Object-Partitions-amp-Bounding-Volume-Hierarchy-BVH"><a href="#Object-Partitions-amp-Bounding-Volume-Hierarchy-BVH" class="headerlink" title="Object Partitions &amp; Bounding Volume Hierarchy (BVH)"></a>Object Partitions &amp; Bounding Volume Hierarchy (BVH)</h2><p>将原有的图形分为好几部分,每一个几何结构只有可能在一个包围盒中出现,即只储存在一个叶子节点中<br>但也会导致,划分不是严格的划分,bounding box 之间会有相交.质量越好的划分,bounding box 之间的重叠越小<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107224425.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107224825.png" alt=""></p>
<h4 id="具体划分方法"><a href="#具体划分方法" class="headerlink" title="具体划分方法"></a>具体划分方法</h4><ul>
<li>Choose a dimension to split<br>类似kd-tree,横竖横竖地顺序划分</li>
<li>Heuristic #1: Always choose the longest axis in node<br>对于长方形的图像,垂直于长,进行划分</li>
<li>Heuristic #2: Split node at location of median object<br>尽量从中间的三角形划分,保证划分之后,两个新的叶子节点,所包含的三角形的数量接近,实现平衡二叉树的样子</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107225905.png" alt=""></p>
<h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Intersect</span>(Ray ray, BVH node) &#123;              </span><br><span class="line">	<span class="keyword">if</span> (ray misses node.bbox) <span class="keyword">return</span>;       <span class="comment">//光线和整个BVH节点不相交，什么也不发生</span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">if</span> (node is a leaf node)                <span class="comment">//如果光线与BVH的叶子节点相交</span></span><br><span class="line">		test intersection with all objs;      <span class="comment">//和节点内所有物体都求交</span></span><br><span class="line">		<span class="keyword">return</span> closest intersection;          <span class="comment">//返回最近的交点</span></span><br><span class="line">		</span><br><span class="line">		hit1 = <span class="built_in">Intersect</span>(ray, node.child1);   <span class="comment">//如果相交的不是叶子节点，那光线与两个子节点都可能相交</span></span><br><span class="line">		hit2 = <span class="built_in">Intersect</span>(ray, node.child2);   <span class="comment">//分别与两个子节点求交</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> the closer of hit1, hit2;      <span class="comment">//返回最近的交点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Basic-radiometry-辐射度量学"><a href="#Basic-radiometry-辐射度量学" class="headerlink" title="Basic radiometry (辐射度量学)"></a>Basic radiometry (辐射度量学)</h2><p>鉴于whitted-style模型是一个简化过之后的光线追踪模型,与实际上的情况有着一定的区别.<br>辐射度量学就是为了做出更加贴近于现实的光线追踪.<br>New terms: Radiant flux, intensity, irradiance, radiance<br>从物理的角度正确表示光线</p>
<h3 id="Radiant-flux"><a href="#Radiant-flux" class="headerlink" title="Radiant flux"></a>Radiant flux</h3><p>Radiant Energy为能量,单位为$Q$,焦耳<br>Radiant flux(power)为单位时间内的能量,$\phi=\frac{dQ}{dt}$,单位为$W$,或者$lm$,流明 其实就是功率<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107234309.png" alt=""></p>
<h3 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h3><p>光源发出的每单位角的光的功率<br>$I(\omega)=\frac{d\Phi}{d\omega}\;\;\;\;[\frac{W}{s r}][\frac{l m}{s r}=c d=c a n d e l a]$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107234554.png" alt=""></p>
<p>what is solid angle?<br>在二维空间中,用弧长与半径的比值来定义角<br>在三维空间中,用面积与半径的平方来定义立体角<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107234623.png" alt=""></p>
<p>单位立体角<br>由高等数学计算得出,球体上单位面积对应的单位立体角为$\mathrm{d}\omega=\frac{\mathrm{d}A}{r^{2}}=\sin\theta\,\mathrm{d}\theta\,\mathrm{d}\phi$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107234851.png" alt=""></p>
<p>用$\omega$来表示单位向量<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107235546.png" alt=""></p>
<p>对于一个向四面八方发射光线的点光源,光照强度相同,且由积分可算得<br>$I=\frac{\phi}{4\pi}$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231107235724.png" alt=""></p>
<h1 id="Lec15-ray-tracing-3"><a href="#Lec15-ray-tracing-3" class="headerlink" title="Lec15 ray tracing 3"></a>Lec15 ray tracing 3</h1><h2 id="irradiance"><a href="#irradiance" class="headerlink" title="irradiance"></a>irradiance</h2><p>在单位面积上的功率<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231112142552.png" alt=""></p>
<h2 id="radiance"><a href="#radiance" class="headerlink" title="radiance"></a>radiance</h2><p>per unit solid angle,per projected unit area </p>
<p>某个面向某个方向辐射能量<br>要确定面与方向<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231115154345.png" alt=""></p>
<ul>
<li>Radiance: Irradiance per solid angle</li>
<li>Radiance: Intensity per projected unit area</li>
</ul>
<h3 id="Irradiance-vs-Radiance"><a href="#Irradiance-vs-Radiance" class="headerlink" title="Irradiance vs. Radiance"></a>Irradiance vs. Radiance</h3><p>对各个方向的radiance求积分,可以得到irradiance<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231115155224.png" alt=""></p>
<h2 id="DRBF-Bidirectional-Reflectance-Distribution-Function"><a href="#DRBF-Bidirectional-Reflectance-Distribution-Function" class="headerlink" title="DRBF Bidirectional Reflectance Distribution Function"></a>DRBF Bidirectional Reflectance Distribution Function</h2><p>描述一个unit area 接受的某个方向上的radiance,经过反射后,会向某方向反射的radiance大小.</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231115162330.png" alt=""></p>
<p>BRDF<br>描述每一个入射光与每一个出射光的关系<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231115162840.png" alt=""></p>
<p>The Reflection Equation<br>对于确定的出射方向,计算各个入射方向的积分.<br>入射的光线除了点光源,还会有一次反射,二次反射等等之后产生的光线.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231115162956.png" alt=""></p>
<h3 id="rendering-equation"><a href="#rendering-equation" class="headerlink" title="rendering equation"></a>rendering equation</h3><p>除了上方的渲染方程之外,还增加了,观测点本身发光的情况下发出的光源.<br>求积分,只对上半球体求,下半球体默认为0<br>$(n \cdot w_{i})$就是$\cos \theta_{i}$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231121131456.png" alt=""></p>
<h4 id="单个点光源"><a href="#单个点光源" class="headerlink" title="单个点光源"></a>单个点光源</h4><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122115851.png" alt=""></p>
<h4 id="多个点光源"><a href="#多个点光源" class="headerlink" title="多个点光源"></a>多个点光源</h4><p>sum函数求和<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122115920.png" alt=""></p>
<h4 id="面光源"><a href="#面光源" class="headerlink" title="面光源"></a>面光源</h4><p>integral求积分<br>面光源是点光源的大集合<br>对面光源所在的立体角进行积分<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122115948.png" alt=""></p>
<h4 id="其他物体反射光源"><a href="#其他物体反射光源" class="headerlink" title="其他物体反射光源"></a>其他物体反射光源</h4><p>光源不一定来自直接光源,也有可能来自其他的物体反射出来的光源<br>计算物体反射光线对应的立体角<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122120343.png" alt=""></p>
<h3 id="式子化简"><a href="#式子化简" class="headerlink" title="式子化简"></a>式子化简</h3><p>对式子进行数学化简<br>$(x,w_{r})=u$ $(x^{\prime},-w_{i})=v$<br>最后化简为只与L,E,K有关的式子<br>E为自发光,L为光线,K为由BRDF得到的转换矩阵,将入射光线L转换为出射光线<br>L, E are vectors, K is the light transport matrix<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122120558.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122120614.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122120829.png" alt=""><br>矩阵也有类似于泰勒展开的性质,对于$(I-K)^{-1}$可以展开为$(I+K+K^{2}+K^{3}+…)$,$I$为单位矩阵.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122130435.png" alt=""><br>$E$ 为自发光<br>$KE$ 为直接光照<br>$K^{2}E$ 为间接光照<br>全局光照=直接光照+间接光照<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122130647.png" alt=""><br>本质就是解方程,计算出变换矩阵$E$和由BFDR定义的$K$就能解出最终$L$的结果</p>
<p>普通的rasterization只对自发光和直接光照处理,虽然也可以处理间接光照,但有难度.</p>
<h2 id="概率论复习"><a href="#概率论复习" class="headerlink" title="概率论复习"></a>概率论复习</h2><h1 id="Lec16-ray-tracing-4"><a href="#Lec16-ray-tracing-4" class="headerlink" title="Lec16 ray tracing 4"></a>Lec16 ray tracing 4</h1><h2 id="黎曼积分"><a href="#黎曼积分" class="headerlink" title="黎曼积分"></a>黎曼积分</h2><p>对于$f(x)$求积分,黎曼积分方法是,先将积分域内,划分为数量众多的等宽的长方形,对每个长方形求面积,再对面积求sum,最终得到的结果近似积分结果<br><strong>微元法</strong></p>
<h2 id="Monte-Carlo-Integration"><a href="#Monte-Carlo-Integration" class="headerlink" title="Monte Carlo Integration"></a>Monte Carlo Integration</h2><p>对于不定积分,最终的计算结果是一个函数$f(x)$<br>而对于定积分,最终的计算结果是一个值</p>
<p>传统的方法是,先求积分之后的函数,再带入积分域的上下限,从而求得定积分的值.<br>但对于某些函数来说,对他求积分函数是相当困难的.既然最终结果为值,那就可以绕过函数求解,直接对结果进行近似.</p>
<p>对于积分域,进行采样操作,对每次采样的结果求面积,再求出定积分.再对多次采样的定积分的值,进行平均.<br><strong>采样法</strong></p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122144311.png" alt=""></p>
<p>积分通式:<br>  <img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122144612.png" alt=""><br>$p(x)$为采样对应的概率密度函数PDF</p>
<p>采样越多,误差越小<br>在哪个轴上采样,就在哪个轴上积分</p>
<h2 id="Whitted-Style-Ray-Tracing-的问题"><a href="#Whitted-Style-Ray-Tracing-的问题" class="headerlink" title="Whitted-Style Ray Tracing 的问题"></a>Whitted-Style Ray Tracing 的问题</h2><p>Whitted-Style Ray Tracing 模型本身存在局限<br>对于光线的反射只有两种结果</p>
<ol>
<li>完全的镜面反射</li>
<li>光线完全漫反射,并不对漫反射的之后的光线进行处理<br>对于处理glossy材质的反射效果较差.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122145220.png" alt=""></li>
</ol>
<h2 id="Monte-Carlo-Solution"><a href="#Monte-Carlo-Solution" class="headerlink" title="Monte Carlo Solution"></a>Monte Carlo Solution</h2><h3 id="只考虑直接光照"><a href="#只考虑直接光照" class="headerlink" title="只考虑直接光照"></a>只考虑直接光照</h3><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122163223.png" alt=""><br>最简单的对于半球所有方向平均采样的Monte Carlo 积分<br>$pdf=\frac{1}{2 \pi}$<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122163236.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122163412.png" alt=""><br>伪代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">  Randomly choose N directions wi~pdf</span><br><span class="line">  Lo = <span class="number">0.0</span></span><br><span class="line">  For each wi</span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    If ray r hit the light</span><br><span class="line">        Lo += (<span class="number">1</span> / N) * L_i * f_r * cosine / pdf(wi)</span><br><span class="line">  Return Lo</span><br></pre></td></tr></table></figure></p>
<h3 id="分布式光线追踪"><a href="#分布式光线追踪" class="headerlink" title="分布式光线追踪"></a>分布式光线追踪</h3><p>处理直接光照+间接光照<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122163708.png" alt=""></p>
<p>伪代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">  Randomly choose N directions wi~pdf</span><br><span class="line">  Lo = <span class="number">0.0</span></span><br><span class="line">  For each wi</span><br><span class="line">    Trace a ray r(p, wi)</span><br><span class="line">    If ray r hit the light</span><br><span class="line">        Lo += (<span class="number">1</span> / N) * L_i * f_r * cosine / pdf(wi)</span><br><span class="line">    Else If ray r hit an object at q</span><br><span class="line">        Lo += (<span class="number">1</span> / N) * shade(q, -wi) * f_r * cosine</span><br><span class="line">        / pdf(wi)</span><br><span class="line">  Return Lo</span><br></pre></td></tr></table></figure><br>进行else判断,对没有找到直接光照的点,寻找间接光照</p>
<p>但这样的算法还是有问题<br>由于要进行采样,每个角度随机发散出光线,每次间接光照的情况都会导致采样指数增长<br>$n\neq 1$ 这就叫做分布式光线追踪<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122164828.png" alt=""></p>
<h2 id="路径追踪"><a href="#路径追踪" class="headerlink" title="路径追踪"></a>路径追踪</h2><p>处理直接光照+间接光照,但与分布式光线追踪不同<br>only 1 ray is traced at each shading point<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">  Randomly choose ONE direction wi~pdf(w)</span><br><span class="line">  Trace a ray <span class="title function_">r</span><span class="params">(p, wi)</span></span><br><span class="line">  If ray r hit the light</span><br><span class="line">    Return L_i * f_r * cosine / <span class="title function_">pdf</span><span class="params">(wi)</span></span><br><span class="line">  Else If ray r hit an object at q</span><br><span class="line">    Return <span class="title function_">shade</span><span class="params">(q, -wi)</span> * f_r * cosine / <span class="title function_">pdf</span><span class="params">(wi)</span></span><br></pre></td></tr></table></figure><br>This is path tracing!</p>
<p>但由于光线数量过少,导致结果失真</p>
<p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122165212.png" alt=""><br>光线生成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ray_generation(camPos, pixel)</span><br><span class="line">  Uniformly choose N sample positions within the pixel</span><br><span class="line">  pixel_radiance = <span class="number">0.0</span></span><br><span class="line">  For each sample in the pixel</span><br><span class="line">    Shoot a ray r(camPos, cam_to_sample)</span><br><span class="line">    If ray r hit the scene at p</span><br><span class="line">      pixel_radiance += <span class="number">1</span> / N * shade(p, sample_to_cam)</span><br><span class="line">  Return pixel_radiance</span><br></pre></td></tr></table></figure></p>
<p>路径追踪代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">  Randomly choose ONE direction wi~pdf(w)</span><br><span class="line">  Trace a ray <span class="title function_">r</span><span class="params">(p, wi)</span></span><br><span class="line">  If ray r hit the light</span><br><span class="line">    Return L_i * f_r * cosine / <span class="title function_">pdf</span><span class="params">(wi)</span></span><br><span class="line">  Else If ray r hit an object at q</span><br><span class="line">    Return <span class="title function_">shade</span><span class="params">(q, -wi)</span> * f_r * cosine / <span class="title function_">pdf</span><span class="params">(wi)</span></span><br></pre></td></tr></table></figure><br>解决了运算指数爆炸的问题,但还存在问题<br><code>The recursive algorithm will never stop!</code></p>
<p>但简单地限制光线弹射的次数(即限制递归的次数)是不够令人满意的<br>这必然会造成某些多次反射的光线没有被计算,被舍弃,能量不守恒了🤔🤔🤔</p>
<h3 id="Russian-Roulette-RR"><a href="#Russian-Roulette-RR" class="headerlink" title="Russian Roulette (RR)."></a>Russian Roulette (RR).</h3><p>设定一个值P<br>With probability 0 &lt; P &lt; 1, shoot a ray and return the shading result divided by P: <code>Lo / P</code><br>With probability 1 - P, don’t shoot a ray and you’ll get <code>0</code><br>通过概率判定是否要继续path tracing<br>期望得到的能量与实际上的能量相等<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122192511.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">  Manually specify a probability P_RR</span><br><span class="line">  Randomly select ksi in a uniform dist. in [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">  If (ksi &gt; P_RR) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  </span><br><span class="line">  Randomly choose ONE direction wi~pdf(w)</span><br><span class="line">  Trace a ray <span class="title function_">r</span><span class="params">(p, wi)</span></span><br><span class="line">  If ray r hit the light</span><br><span class="line">    Return L_i * f_r * cosine / <span class="title function_">pdf</span><span class="params">(wi)</span> / P_RR</span><br><span class="line">  Else If ray r hit an object at q</span><br><span class="line">    Return <span class="title function_">shade</span><span class="params">(q, -wi)</span> * f_r * cosine / <span class="title function_">pdf</span><span class="params">(wi)</span> / P_RR</span><br></pre></td></tr></table></figure>
<p>递归以概率的方式停下来</p>
<h3 id="算法优化-sampling-the-light"><a href="#算法优化-sampling-the-light" class="headerlink" title="算法优化 sampling the light"></a>算法优化 sampling the light</h3><p>联系之前,信号与采样的关系可以得出<br>光源越小,光源周围的信号变化越大,对采样要求越高.<br>这样对投射出去的光线的浪费也越多<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122193745.png" alt=""></p>
<p>但如果能在光源上采样,就不会浪费性能了.<br>但也带来一个新问题,Monte Carlo methods要求必须,在哪里采样就在哪里积分.对光源面采样,就一定要在光源面上积分,原来对于半球体的积分函数就要转换<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122194021.png" alt=""></p>
<p>两个积分函数之间的积分域相互联系起来.<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122194758.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122194809.png" alt=""></p>
<p>对于直接光源部分,采用优化算法,不需要RR<br>对于间接光源部分,采用原来算法<br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122194947.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">  # Contribution from the light source.</span><br><span class="line">  Uniformly sample the light at x’ (pdf_light = <span class="number">1</span> / A)</span><br><span class="line">  L_dir = L_i * f_r * <span class="built_in">cos</span> θ * <span class="built_in">cos</span> θ’ / |x’ - p|^<span class="number">2</span> / pdf_light</span><br><span class="line">  # Contribution from other reflectors.</span><br><span class="line">  L_indir = <span class="number">0.0</span></span><br><span class="line">  Test Russian Roulette with probability P_RR</span><br><span class="line">  Uniformly sample the hemisphere toward wi (pdf_hemi = <span class="number">1</span> / <span class="number">2</span>pi)</span><br><span class="line">  Trace a ray r(p, wi)</span><br><span class="line">  If ray r hit a non-emitting object at q</span><br><span class="line">    L_indir = shade(q, -wi) * f_r * <span class="built_in">cos</span> θ / pdf_hemi / P_RR</span><br><span class="line">  Return L_dir + L_indir</span><br></pre></td></tr></table></figure>
<p>最后一个小问题,可能会有物体阻挡在光源与观察点之间<br>需要增加一个小判断<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Contribution from the light source.</span><br><span class="line">L_dir = <span class="number">0.0</span></span><br><span class="line">Uniformly sample the light at x’ (pdf_light = <span class="number">1</span> / A)</span><br><span class="line">Shoot a ray from p to x’</span><br><span class="line">If the ray is not blocked in the middle</span><br><span class="line">L_dir = …</span><br></pre></td></tr></table></figure></p>
<h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><p><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122194947.png" alt=""><br><img src="http://172.16.36.4:9000/picture-bucket/Pasted%20image%2020231122201435.png" alt=""></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-10-04T06:12:56.324Z" title="2023/10/4 14:12:56">2023-10-04</time>发表</span><span class="level-item"><time dateTime="2023-11-28T12:56:09.309Z" title="2023/11/28 20:56:09">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/tech/">tech</a><span> / </span><a class="link-muted" href="/categories/tech/games/">games</a></span><span class="level-item">1 分钟读完 (大约178个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/10/714224f23965.html">102</a></h1><div class="content"><h2 id="Lec1-课程介绍"><a href="#Lec1-课程介绍" class="headerlink" title="Lec1 课程介绍"></a>Lec1 课程介绍</h2><p>GAMES:Graphics And Mixed Environment Symposium</p>
<p>101偏渲染<br>201偏动画<br>102偏建模</p>
<p>图像是由像素表达的离散的点<br>图形是具有数学表达的几何对象,矢量图</p>
<h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>文字都是矢量图,不论怎么放大都是清晰的<br>储存的是点线的坐标,在经过重新计算之后,会清晰的呈现出来</p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>光的计算科学</p>
<ol>
<li>光源</li>
<li>几何</li>
<li>纹理</li>
<li>材质</li>
</ol>
<h3 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h3><p>运动的计算科学 偏微分方程</p>
<h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul>
<li>集合<ul>
<li>无限<ul>
<li>可数 自然数N,有理数Q</li>
<li>不可数 实数R,无理数<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/361519628/answer/2453301335">对于有理数可数,无理数不可数的证明</a></li>
</ul>
</li>
<li>有限</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-20T02:58:43.743Z" title="2023/9/20 10:58:43">2023-09-20</time>发表</span><span class="level-item"><time dateTime="2023-11-28T12:57:38.333Z" title="2023/11/28 20:57:38">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/tutorial/">tutorial</a></span><span class="level-item">2 分钟读完 (大约334个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/e137e4e7e5ce.html">latex</a></h1><div class="content"><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nowgood/p/latexstart.html">refering</a></p>
<h2 id="数学模式"><a href="#数学模式" class="headerlink" title="数学模式"></a>数学模式</h2><h3 id="行内与行间"><a href="#行内与行间" class="headerlink" title="行内与行间"></a>行内与行间</h3><p>排版有所不同,行内更适合短式子,行间更适合长式子或者公式推导</p>
<ul>
<li><p>行内公式<br>${f(x)=a_nx^n+a_{n-1}x^{n-1}+a_{n-2}x^{n-2}}+\cdots$</p>
</li>
<li><p>行间公式</p>
<script type="math/tex; mode=display">{f(x)=a_nx^n+a_{n-1}x^{n-1}+a_{n-2}x^{n-2}}+\cdots \tag{1.1}</script></li>
</ul>
<h3 id="输入上下标"><a href="#输入上下标" class="headerlink" title="输入上下标"></a>输入上下标</h3><p><code>^</code> 表示上标, <code>_</code> 表示下标。<br>$\sum_i^na_i$<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>i<span class="built_in">^</span>na<span class="built_in">_</span>i<span class="built_in">$</span></span><br></pre></td></tr></table></figure></p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>一般的输入形式<br>$x=2\div3$<br>分数的输入形式为 <code>\frac&#123;分子&#125;&#123;分母&#125;</code><br>$P(v)=\frac{1}{1+exp(-v/T)}$<br><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span>P(v)=<span class="keyword">\frac</span>&#123;1&#125;&#123;1+exp(-v/T)&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure></p>
<h3 id="上下划线与花括号"><a href="#上下划线与花括号" class="headerlink" title="上下划线与花括号"></a>上下划线与花括号</h3><script type="math/tex; mode=display">\begin{array} \overline{a+b+c} \\ \underline{a+b+c} \\ \overleftarrow{a+b} \\ \underleftarrow{a+b} \\ \underleftrightarrow{a+b} \\ \vec x = \vec{AB} \\ \overbrace {a+b}^\text{a,b} \\ a+\rlap{\overbrace{\phantom{b+c+d}}^m}b+\underbrace{c+d+e}_n+f \end{array}</script><h3 id="输入根号"><a href="#输入根号" class="headerlink" title="输入根号"></a>输入根号</h3><p>$\sqrt{12}$<br>$\sqrt[n]{12}$ </p>
<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><script type="math/tex; mode=display">
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} & \mathbf{j} & \mathbf{k} \\
\frac{\partial X}{\partial u} &  \frac{\partial Y}{\partial u} & 0 \\
\frac{\partial X}{\partial v} &  \frac{\partial Y}{\partial v} & 0 \\
\end{vmatrix}</script><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>表示方法<br>$\vec {a}$<br>or<br>$\boldsymbol {a}$<br>点乘：$a \cdot b$</p>
<p>叉乘：$a \times b$</p>
<p>除以：$a \div b$</p>
<p>单位向量: $\hat{a}$</p>
<h3 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h3><p>$\lvert a \rvert$</p>
<p>$A^T=(x,y)$</p>
<h3 id="矩阵-1"><a href="#矩阵-1" class="headerlink" title="矩阵"></a>矩阵</h3><p>不同的括号名字不同</p>
<p>$\begin{pmatrix} a \\ b \end{pmatrix}$</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
a & b & c \\
d & e & f \\
g & h & i 
\end{pmatrix}</script><script type="math/tex; mode=display">
\chi(\lambda) =  
\begin{vmatrix}
\lambda - a & -b & -c \\
-d & \lambda - e & -f \\
-g & -h & \lambda - i 
\end{vmatrix}</script></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-19T10:28:44.330Z" title="2023/9/19 18:28:44">2023-09-19</time>发表</span><span class="level-item"><time dateTime="2023-11-28T12:56:14.645Z" title="2023/11/28 20:56:14">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/tech/">tech</a></span><span class="level-item">7 分钟读完 (大约1010个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/09/52777c955357.html">lisp</a></h1><div class="content"><h2 id="Lec1a"><a href="#Lec1a" class="headerlink" title="Lec1a"></a>Lec1a</h2><ul>
<li>编程就像念咒语</li>
<li>从另外一个角度看computer science<br>computer science是一个糟糕的名字.这门学科中所包括的不仅仅是computer,并且它也并不是科学,而更接近于tech or engineering.<br>geometry,几何学,名字来源于gaia meaning to earth,and metron meaning to measure.埃及祭司用来计算每年被尼罗河摧毁的土地边界,从而创立了几何学.对于他们来说,geometry确实是用来测量土地.但几何学本身的内容早就已经超出了最开始的范围.<br>cs也是这样.它不仅仅是介绍计算机使用.<br>但是回过头看千年前埃及人的工作,他们开始形式化地对空间与时间进行描述.并且归纳出了一套讨论数学真理的形式化方法.这直接导致了公理化方法,促进了现代数学的诞生,指明了一种精确讨论何为真理的方法.<br>同样的,千年之后的人类回头看我们现在的cs,会作何评价?我们只是摆弄着一个叫做计算机的小玩意,但却真正意义上开始了对于计算过程的形式化表示,并结合实际需求,发展出一套问题处理过程精确描述的方法.<br>下面来举个栗子：</li>
</ul>
<p>我们都知道平方根的定义：</p>
<blockquote>
<p>$\sqrt{x}$是满足$y^2=x$同时$y≥0$</p>
</blockquote>
<p>这个定义告诉了你平方根是什么，却没有告诉你如何求一个平方根。<br>这里提供亚历山大Heron提出的一叫连续取均值求平方根法。下面列出形式化的描述：</p>
<blockquote>
<p>如何求$\sqrt{x}$的平方根？<br>1.随便猜一个数叫$G$<br>2.改进你的猜想通过计算 $G$ 和 $X/G$的平均值<br>3.不断重复步骤2，直到满意为止</p>
</blockquote>
<p>对于cs来说,我们要完成的是拥有一个定义之后,实现它的具体而精确的计算过程.</p>
<h2 id="Lec2b"><a href="#Lec2b" class="headerlink" title="Lec2b"></a>Lec2b</h2><ul>
<li>数据抽象 data abstraction<br>用构造函数与选择函数来分隔 数据的表示与数据的使用<br>例如构建一段关于点,线的代码段<br>从层次结构上看,分成了三层<br><strong>segments</strong><br>make-seg seg-start seg-end (构造函数与选择函数)<br><strong>vectors</strong><br>make-vertor xcor ycor (构造函数与选择函数)<br><strong>pairs</strong></li>
<li>重要的不是某个小功能的本身,而是我能够用这个小block来搭建什么</li>
<li>模糊数据与过程的边界是有利的.<h2 id="Lec3a"><a href="#Lec3a" class="headerlink" title="Lec3a"></a>Lec3a</h2></li>
<li>封闭性(closure)是一个非常良好的特性.在缺少封闭性的语言中,你可以使用字符串,数字等去构造数组.但不能用数组去构造数组.<br>例如用cons去构建cons<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cons(<span class="number">1</span></span><br><span class="line">     cons(<span class="number">1</span> <span class="number">2</span>))  </span><br></pre></td></tr></table></figure></li>
<li>regard the procedure and data as the same thing </li>
<li>当你有一项任务要完成时候,有两种情况<br>你把它分解成为几个sub-tasks,再把sub-tasks分解成又几个sub-tasks,成为一个树的形状.<br>或者,选择使用层级结构.在每个层级只讨论描述该层级的事件,从而实现良好的分层.<br>层级结构与书级结构的差距在于:层级是为了讨论整个事件,而树形只是为了解决这个具体的问题.原因在于,对于相似的事件,他们有相似的层级结构,但在树形上,因为处理到的具体细节的不同,存在较大的差距.<br>层级具有更好的robust,当你做出某些改变时,会做出相应的回应.想要改变某层的效果,只要去更改更底层的内容.<br>并且,在每一层都有完备的语言去描述具体的操作.因而,想要实现某些变化的时候,你可以选择在某个具体的层级改变.<br>这使得计算机科学比其他的工程学更加强大<h2 id="Lec3b"><a href="#Lec3b" class="headerlink" title="Lec3b"></a>Lec3b</h2></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-07-30T08:27:52.097Z" title="2023/7/30 16:27:52">2023-07-30</time>发表</span><span class="level-item"><time dateTime="2023-11-28T08:12:06.206Z" title="2023/11/28 16:12:06">2023-11-28</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/literature/">literature</a><span> / </span><a class="link-muted" href="/categories/literature/share/">share</a></span><span class="level-item">1 分钟读完 (大约126个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/07/384ecbfbcdbe.html">散户与垄断</a></h1><div class="content"><p>大部分散户基本只能追涨杀跌，结果就是反复的猪周期，既折磨消费者，也导致很多散户收入过山车甚至赔本。根子上，农业必须规模化产业化集中化，关键在于这个过程中如何保障农民利益。而以“农民以此为生”为理由把农民绑在小农经济中，这不过是一种自我满足式的“良心”。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-2-desktop is-2-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="l4rk"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">l4rk</p><p class="is-size-6 is-block">The time has gone.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>hangzhou,zhejiang</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">39</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/cnHuaShao" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/domonnss"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:2876359363@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-27T12:25:09.880Z">2023-11-27</time></p><p class="title"><a href="/2023/11/0f5b30ebc6d1.html">dns</a></p><p class="categories"><a href="/categories/tech/">tech</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-27T12:24:35.637Z">2023-11-27</time></p><p class="title"><a href="/2023/11/6b01a7b16a40.html">oos</a></p><p class="categories"><a href="/categories/tech/">tech</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-26T06:04:41.764Z">2023-11-26</time></p><p class="title"><a href="/2023/11/74ebd10381d1.html">api</a></p><p class="categories"><a href="/categories/tech/">tech</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-26T06:02:28.240Z">2023-11-26</time></p><p class="title"><a href="/2023/11/8b337fe9c1ef.html">cdn</a></p><p class="categories"><a href="/categories/tech/">tech</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-25T12:50:28.523Z">2023-11-25</time></p><p class="title"><a href="/2023/11/dcbe7675465f.html">hello-world&#039;</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-2-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/literature/"><span class="level-start"><span class="level-item">literature</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/literature/book/"><span class="level-start"><span class="level-item">book</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/literature/share/"><span class="level-start"><span class="level-item">share</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/tech/"><span class="level-start"><span class="level-item">tech</span></span><span class="level-end"><span class="level-item tag">18</span></span></a><ul><li><a class="level is-mobile" href="/categories/tech/games/"><span class="level-start"><span class="level-item">games</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/tutorial/"><span class="level-start"><span class="level-item">tutorial</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/07/"><span class="level-start"><span class="level-item">七月 2023</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li></ul></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="l4rk&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 l4rk</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/live2d-widget/autoload.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>